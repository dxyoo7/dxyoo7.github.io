<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Martin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dxyoo7.github.io/"/>
  <updated>2018-04-11T08:37:08.000Z</updated>
  <id>http://dxyoo7.github.io/</id>
  
  <author>
    <name>Martin D</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Architecture Components研究</title>
    <link href="http://dxyoo7.github.io/2018/04/11/Android-Architecture-Components-md/"/>
    <id>http://dxyoo7.github.io/2018/04/11/Android-Architecture-Components-md/</id>
    <published>2018-04-11T08:08:29.000Z</published>
    <updated>2018-04-11T08:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Google IO 2017发布Android Architecture Components，自己先研究了一下，蛮有意思的，特来记录一下。本文内容主要是参考官方文档以及自己的理解，如有错误之处，恳请指出。</p><p>Android Architecture Components<br>Android Architecture Components是Google发布的一套新的架构组件，使App的架构更加健壮，后面简称AAC。</p><p>AAC主要提供了Lifecycle，ViewModel，LiveData，Room等功能，下面依次说明：</p><p><strong>Lifecycle</strong><br>生命周期管理，把原先Android生命周期的中的代码抽取出来，如将原先需要在onStart()等生命周期中执行的代码分离到Activity或者Fragment之外。</p><p><strong>LiveData</strong><br>一个数据持有类，持有数据并且这个数据可以被观察被监听，和其他Observer不同的是，它是和Lifecycle是绑定的，在生命周期内使用有效，减少内存泄露和引用问题。</p><p><strong>ViewModel</strong><br>用于实现架构中的ViewModel，同时是与Lifecycle绑定的，使用者无需担心生命周期。可以在多个Fragment之间共享数据，比如旋转屏幕后Activity会重新create，这时候使用ViewModel还是之前的数据，不需要再次请求网络数据。</p><p><strong>Room</strong><br>谷歌推出的一个Sqlite ORM库，不过使用起来还不错，使用注解，极大简化数据库的操作，有点类似Retrofit的风格。</p><p>AAC的架构是这样的：<br><img src="https://raw.githubusercontent.com/LiushuiXiaoxia/AndroidArchitectureComponents/master/doc/final-architecture.png" alt="AAC"></p><ul><li>Activity/Fragment</li></ul><p>UI层，通常是Activity/Fragment等，监听ViewModel，当VIewModel数据更新时刷新UI，监听用户事件反馈到ViewModel，主流的数据驱动界面。</p><ul><li>ViewModel</li></ul><p>持有或保存数据，向Repository中获取数据，响应UI层的事件，执行响应的操作，响应数据变化并通知到UI层。</p><ul><li>Repository</li></ul><p>App的完全的数据模型，ViewModel交互的对象，提供简单的数据修改和获取的接口，配合好网络层数据的更新与本地持久化数据的更新，同步等</p><ul><li>Data Source</li></ul><p>包含本地的数据库等，网络api等，这些基本上和现有的一些MVVM，以及Clean架构的组合比较相似</p><p><strong>Gradle 集成</strong></p><p>根目录gradle文件中添加Google Maven Repository</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url &apos;https://maven.google.com&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模块中添加对应的依赖</p><p>如使用Lifecycle,LiveData、ViewModel，添加如下依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;android.arch.lifecycle:runtime:1.0.0-alpha1&quot;</span><br><span class="line">compile &quot;android.arch.lifecycle:extensions:1.0.0-alpha1&quot;</span><br><span class="line">annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0-alpha1&quot;</span><br></pre></td></tr></table></figure><p>如使用Room功能，添加如下依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;android.arch.persistence.room:runtime:1.0.0-alpha1&quot;</span><br><span class="line">annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0-alpha1&quot;</span><br><span class="line"></span><br><span class="line">// For testing Room migrations, add:</span><br><span class="line">testCompile &quot;android.arch.persistence.room:testing:1.0.0-alpha1&quot;</span><br><span class="line"></span><br><span class="line">// For Room RxJava support, add:</span><br><span class="line">compile &quot;android.arch.persistence.room:rxjava2:1.0.0-alpha1&quot;</span><br></pre></td></tr></table></figure><h3 id="LifeCycles"><a href="#LifeCycles" class="headerlink" title="LifeCycles"></a>LifeCycles</h3><p>Android开发中，经常需要管理生命周期。举个栗子，我们需要获取用户的地址位置，当这个Activity在显示的时候，我们开启定位功能，然后实时获取到定位信息，当页面被销毁的时候，需要关闭定位功能。</p><p>下面是简单的示例代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyLocationListener &#123;</span><br><span class="line">    public MyLocationListener(Context context, Callback callback) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void start() &#123;</span><br><span class="line">        // connect to system location service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void stop() &#123;</span><br><span class="line">        // disconnect from system location service</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = new MyLocationListener(this, (location) -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只是一个简单的场景，我们来个复杂一点的场景。当定位功能需要满足一些条件下才开启，那么会变得复杂多了。可能在执行Activity的stop方法时，定位的start方法才刚刚开始执行，比如如下代码，这样生命周期管理就变得很麻烦了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity extends AppCompatActivity &#123;</span><br><span class="line">    private MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = new MyLocationListener(this, location -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            // what if this callback is invoked AFTER activity is stopped?</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AAC中提供了Lifecycle，用来帮助我们解决这样的问题。LifeCycle使用2个枚举类来解决生命周期管理问题。一个是事件，一个是状态。</p><p>事件：</p><p>生命周期事件由系统来分发，这些事件对于与Activity和Fragment的生命周期函数。</p><p>状态：</p><p>Lifecycle的状态，用于追踪中Lifecycle对象，如下图所示。</p><p><img src="https://raw.githubusercontent.com/LiushuiXiaoxia/AndroidArchitectureComponents/master/doc/lifecycle-states.png" alt=""></p><p>上面的定位功能代码，使用LifeCycle实现以后是这样的，实现一个LifecycleObserver接口，然后用注解标注状态，最后在LifecycleOwner中添加监听。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyObserver implements LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    public void onResume() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    public void onPause() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aLifecycleOwner.getLifecycle().addObserver(new MyObserver());</span><br></pre></td></tr></table></figure><p>上面代码中用到了<code>LifecycleOwner</code>是<code>LifecycleOwner</code>接口对象，<code>LifecycleOwner</code>是一个只有一个方法的接口<code>getLifecycle()</code>，需要由子类来实现。</p><p>在Lib中已经有实现好的子类，我们可以直接拿来使用。比如<code>LifecycleActivity</code>和<code>LifecycleFragment</code>，我们只需要继承此类就行了。</p><p>当然实际开发的时候我们会自己定义<code>BaseActivity</code>，Java是单继承模式，那么需要自己实现<code>LifecycleRegistryOwner</code>接口。</p><p>如下所示即可，代码很近简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BaseFragment extends Fragment implements LifecycleRegistryOwner &#123;</span><br><span class="line"></span><br><span class="line">    LifecycleRegistry lifecycleRegistry = new LifecycleRegistry(this);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LifecycleRegistry getLifecycle() &#123;</span><br><span class="line">        return lifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><code>LiveData</code> 是一个 <code>Data Holder</code> 类，可以持有数据，同时这个数据可以被监听的，当数据改变的时候，可以触发回调。但是又不像普通的Observable，LiveData绑定了App的组件，<code>LiveData</code>可以指定在<code>LifeCycle</code>的某个状态被触发。比如<code>LiveData</code>可以指定在<code>LifeCycle</code>的 <code>STARTED</code> 或 <code>RESUMED</code>状体被触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class LocationLiveData extends LiveData&lt;Location&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private LocationManager locationManager;</span><br><span class="line"></span><br><span class="line">    private SimpleLocationListener listener = new SimpleLocationListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onLocationChanged(Location location) &#123;</span><br><span class="line">            setValue(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public LocationLiveData(Context context) &#123;</span><br><span class="line">        locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onActive() &#123;</span><br><span class="line">        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onInactive() &#123;</span><br><span class="line">        locationManager.removeUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onActive()</code><br>这个方法在<code>LiveData</code>在被激活的状态下执行，我们可以开始执行一些操作。</p><p><code>onActive()</code><br>这个方法在<code>LiveData</code>在的失去活性状态下执行，我们可以结束执行一些操作。</p><p><code>setValue()</code><br>执行这个方法的时候，<code>LiveData</code>可以触发它的回调。</p><p><code>LocationLiveData</code>可以这样使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyFragment extends LifecycleFragment &#123;</span><br><span class="line"></span><br><span class="line">    public void onActivityCreated (Bundle savedInstanceState) &#123;</span><br><span class="line">        LiveData&lt;Location&gt; myLocationListener = ...;</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                myLocationListener.addObserver(this, location -&gt; &#123;</span><br><span class="line">                    // update UI</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面的<code>addObserver</code>方法，必须传<code>LifecycleOwner</code>对象，也就是说添加的对象必须是可以被<code>LifeCycle</code>管理的。</p><p>如果<code>LifeCycle</code>没有触发对对应的状态（<code>STARTED</code> or <code>RESUMED</code>），它的值被改变了，那么<code>Observe</code>就不会被执行，</p><p>如果<code>LifeCycle</code>被销毁了，那么<code>Observe</code>将自动被删除。</p><p>实际上<code>LiveData</code>就提供一种新的供数据共享方式。可以用它在多个<code>Activity</code>、<code>Fragment</code>等其他有生命周期管理的类中实现数据共享。</p><p>还是上面的定位例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class LocationLiveData extends LiveData&lt;Location&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static LocationLiveData sInstance;</span><br><span class="line"></span><br><span class="line">    private LocationManager locationManager;</span><br><span class="line"></span><br><span class="line">    @MainThread</span><br><span class="line">    public static LocationLiveData get(Context context) &#123;</span><br><span class="line">        if (sInstance == null) &#123;</span><br><span class="line">            sInstance = new LocationLiveData(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SimpleLocationListener listener = new SimpleLocationListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onLocationChanged(Location location) &#123;</span><br><span class="line">            setValue(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private LocationLiveData(Context context) &#123;</span><br><span class="line">        locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onActive() &#123;</span><br><span class="line">        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onInactive() &#123;</span><br><span class="line">        locationManager.removeUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Fragment中调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyFragment extends LifecycleFragment &#123;</span><br><span class="line"></span><br><span class="line">    public void onActivityCreated (Bundle savedInstanceState) &#123;</span><br><span class="line"></span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                LocationLiveData.get(getActivity()).observe(this, location -&gt; &#123;</span><br><span class="line">                   // update UI</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的示例，可以得到使用LiveData优点：</p><blockquote><ul><li><p>没有内存泄露的风险，全部绑定到对应的生命周期，当LifeCycle被销毁的时候，它们也自动被移除</p></li><li><p>降低Crash，当Activity被销毁的时候，LiveData的Observer自动被删除，然后UI就不会再接受到通知</p></li><li><p>实时数据，因为LiveData是持有真正的数据的，所以当生命周期又重新开始的时候，又可以重新拿到数据</p></li><li><p>正常配置改变，当Activity或者Fragment重新创建的时候，可以从LiveData中获取上一次有用的数据</p></li></ul></blockquote><p>不再需要手动的管理生命周期</p><p>Transformations<br>有时候需要对一个LiveData做Observer，但是这个LiveData是依赖另外一个LiveData，有点类似于RxJava中的操作符，我们可以这样做。</p><p>Transformations.map()<br>用于事件流的传递，用于触发下游数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class="line">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class="line">    user.name + &quot; &quot; + user.lastName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Transformations.switchMap()<br>这个和map类似，只不过这个是用来触发上游数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private LiveData&lt;User&gt; getUser(String id) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveData&lt;String&gt; userId = ...;</span><br><span class="line">LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );</span><br></pre></td></tr></table></figure></p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel是用来存储UI层的数据，以及管理对应的数据，当数据修改的时候，可以马上刷新UI。</p><p>Android系统提供控件，比如Activity和Fragment，这些控件都是具有生命周期方法，这些生命周期方法被系统调用。</p><p>当这些控件被销毁或者被重建的时候，如果数据保存在这些对象中，那么数据就会丢失。比如在一个界面，保存了一些用户信息，当界面重新创建的时候，就需要重新去获取数据。当然了也可以使用控件自动再带的方法，在onSaveInstanceState方法中保存数据，在onCreate中重新获得数据，但这仅仅在数据量比较小的情况下。如果数据量很大，这种方法就不能适用了。</p><p>另外一个问题就是，经常需要在Activity中加载数据，这些数据可能是异步的，因为获取数据需要花费很长的时间。那么Activity就需要管理这些数据调用，否则很有可能会产生内存泄露问题。最后需要做很多额外的操作，来保证程序的正常运行。</p><p>同时Activity不仅仅只是用来加载数据的，还要加载其他资源，做其他的操作，最后Activity类变大，就是我们常讲的上帝类。也有不少架构是把一些操作放到单独的类中，比如MVP就是这样，创建相同类似于生命周期的函数做代理，这样可以减少Activity的代码量，但是这样就会变得很复杂，同时也难以测试。</p><p>AAC中提供ViewModel可以很方便的用来管理数据。我们可以利用它来管理UI组件与数据的绑定关系。ViewModel提供自动绑定的形式，当数据源有更新的时候，可以自动立即的更新UI。</p><p>下面是一个简单的代码示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyViewModel extends ViewModel &#123;</span><br><span class="line"></span><br><span class="line">    private MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        if (users == null) &#123;</span><br><span class="line">            users = new MutableLiveData&lt;List&lt;Users&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadUsers() &#123;</span><br><span class="line">        // do async operation to fetch users</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(this, users -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们获取ViewModel实例的时候，ViewModel是通过ViewModelProvider保存在LifeCycle中，ViewModel会一直保存在LifeCycle中，直到Activity或者Fragment销毁了，触发LifeCycle被销毁，那么ViewModel也会被销毁的。下面是ViewModel的生命周期图。</p><p><img src="https://raw.githubusercontent.com/LiushuiXiaoxia/AndroidArchitectureComponents/master/doc/viewmodel-lifecycle.png" alt=""></p><h3 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h3><p>（未完待续）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Google IO 2017发布Android Architecture Components，自己先研究了一下，蛮有意思的，特来记录一下。
      
    
    </summary>
    
    
      <category term="Java" scheme="http://dxyoo7.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>npm install 权限问题</title>
    <link href="http://dxyoo7.github.io/2017/11/29/fixing_npm_permissions/"/>
    <id>http://dxyoo7.github.io/2017/11/29/fixing_npm_permissions/</id>
    <published>2017-11-29T07:32:24.000Z</published>
    <updated>2017-11-29T03:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们使用 <code>npm install xxx -g</code> 包很方便，但是有时候会在MAC遇到权限问题。下面有两个办法能够解决这样权限的问题。</p><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们使用 &lt;code&gt;npm install xxx -g&lt;/code&gt; 包很方便，但是有时候会在MAC遇到权限问题。下面有两个办法能够解决这样权限的问题。&lt;/p&gt;
&lt;p&gt;### &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://dxyoo7.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出人脸识别原理</title>
    <link href="http://dxyoo7.github.io/2017/11/28/face_recognition/"/>
    <id>http://dxyoo7.github.io/2017/11/28/face_recognition/</id>
    <published>2017-11-28T08:27:10.000Z</published>
    <updated>2017-11-28T08:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出人脸识别"><a href="#深入浅出人脸识别" class="headerlink" title="深入浅出人脸识别"></a>深入浅出人脸识别</h1><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/in.jpg" alt="in"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前不久<strong>Iphone X</strong>发布，革命性的取消了<strong>TouchID（指纹识别）</strong>，而添加了更酷的 <strong>FaceID(人脸识别)</strong> 模块，<strong>FaceID</strong> 不简单的运用在解锁上，还可以在支付，表情等场景中应用，给开发者带来更酷更丰富的应用，<strong>Iphone X</strong> 在多个硬件传感器的加持下，可以采集3万个点来感知用户的面部特征。<br><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/animoji.gif" alt="animoji"></p><p>我们知道人脸识别在这几年应用相当广泛，人脸考勤，人脸社交，人脸支付，哪里都有这黑科技的影响，特别这几年机器学习流行，使得人脸识别在应用和准确率更是达到了一个较高的水准。</p><p>下面将带着大家揭秘下这项黑科技的原理。</p><h2 id="人脸识别流程："><a href="#人脸识别流程：" class="headerlink" title="人脸识别流程："></a>人脸识别流程：</h2><p>人脸识别是由一系列的几个相关问题组成的：</p><ol><li>首先找到一张图片中的所有人脸。</li><li>对于每一张脸来说，无论光线明暗或面朝别处，它依旧能够识别出是同一个人的脸。</li><li>能够在每一张脸上找出可用于他人区分的独特之处，比如眼睛多大，脸有多长等等。</li><li>最后将这张脸的特点与已知所有人脸进行比较，以确定这个人是谁。</li></ol><h4 id="第一步：找出所有的面孔"><a href="#第一步：找出所有的面孔" class="headerlink" title="第一步：找出所有的面孔"></a>第一步：找出所有的面孔</h4><p>很显然在我们在人脸识别的流程中得首先找到图片中的人脸。我们在使用手机或相机拍照时都会有人像模式，它能轻松的检测出人脸的位置，帮助相机快速对焦。</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/auto_focus.jpg" alt="auto_focus"></p><p>相机对焦我们得感谢 保罗·比奥拉（Paul Viola）和迈克尔·琼斯（Michael Jones）在2000年 发明了一种能够快速在廉价相机上运行的<a href="https://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework" target="_blank" rel="noopener">人脸检测方法</a>，人脸检测在相机上的应用才成为主流。然而现在我们有更可靠的解决方案<strong>HOG</strong>（Histogram of Oriented Gradients）<a href="http://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf" target="_blank" rel="noopener">方向梯度直方图</a>，一种能够检测物体轮廓的算法。</p><p>首先我们把图片灰度化，因为颜色信息对于人脸检测而言没什么用。<br><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/audrey_hepburn.jpg" alt="audrey_hepburn"></p><p>我们分析每个像素以及其周围的像素，根据明暗度画一个箭头，箭头的指向代表了像素逐渐变暗的方向，如果我们重复操作每一个像素，最终像素会被箭头取代。这些箭头被称为<strong>梯度</strong>(gradients)，它们能显示出图像从明亮到黑暗流动的过程。</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/hog_director.jpg" alt="hog_directo"></p><p>分析每个像素对我们来说有点不划算，因为它太过细节化了，我们可能会迷失在像素的海洋里，我们应该从更高的角度观察明暗的流动。</p><p>为此我们将图像分割成16x16像素的小方块。在每个小方块中，计算出每个主方向有多少个剃度（有多少指向上，指向右上，指向右等）。然后用指向性最强的那个方向箭头来代替原来那个小方块。<br><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/face_fhog_filters.png" alt="face_fhog_filters"></p><p>最终结果，我们把原始图像转换成一个非常简单的HOG表达形式，它可以很轻松的捕获面部的基本结构。</p><p>为了在HOG图像中找到脸部，我们需要做的是，与已知的一些HOG图案中，看起来最相似的部分。这些HOG图案都是重其他面部训练数据中提取出来的。</p><h4 id="第二步：脸部的不同姿势"><a href="#第二步：脸部的不同姿势" class="headerlink" title="第二步：脸部的不同姿势"></a>第二步：脸部的不同姿势</h4><p>我们已经找出了图片中的人脸，那么如何鉴别面朝不同方向的人脸呢？</p><p>对于电脑来说朝向不同的人脸是不同的东西，为此我们得适当的调整扭曲图片中的人脸，使得眼睛和嘴总是与被检测者重叠。</p><p>为了达到目的我们将使用一种<strong>面部特征点估计</strong>（face landmark estimation）的算法。其实还有很多算法都可以做到，但我们这次使用的是由<a href="http://www.csc.kth.se/~vahidk/papers/KazemiCVPR14.pdf" target="_blank" rel="noopener">瓦希德·卡奇米（Vahid Kazemi）和约瑟菲娜·沙利文（Josephine Sullivan）在 2014 年发明的方法</a>。</p><p>这一算法的基本思路是找到68个人脸上普遍存在的点（称为<strong>特征点</strong>， landmark）</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/landmark_68_point.jpg" alt="landmark_68_point"></p><ul><li>下巴轮廓17个点 [0-16]</li><li>左眉毛5个点 [17-21]</li><li>右眉毛5个点 [22-26]</li><li>鼻梁4个点 [27-30]</li><li>鼻尖5个点 [31-35]</li><li>左眼6个点 [36-41]</li><li>右眼6个点 [42-47]</li><li>外嘴唇12个点 [48-59]</li><li>内嘴唇8个点 [60-67]</li></ul><p>有了这68个点，我们就可以轻松的知道眼睛和嘴巴在哪儿了，后续我们将图片进行旋转，缩放和错切，使得眼睛和嘴巴尽可能的靠近中心。</p><p>现在人脸基本上对齐了，这使得下一步更加准确。</p><h4 id="第三步：给脸部编码"><a href="#第三步：给脸部编码" class="headerlink" title="第三步：给脸部编码"></a>第三步：给脸部编码</h4><p>我们还有个核心的问题没有解决， 那就是如何区分不同的人脸。</p><p>最简单的方法就是把我们第二步中发现的未知人脸与我们已知的人脸作对比。当我们发现未知的面孔与一个以前标注过的面孔看起来相似的时候，就可以认定他们是同一个人。</p><p>我们人类能通过眼睛大小，头发颜色等等信息轻松的分辨不同的两张人脸，可是电脑怎么分辨呢？没错，我们得量化它们，测量出他们的不同，那要怎么做呢？</p><h5 id="测量人脸的最可靠的方法"><a href="#测量人脸的最可靠的方法" class="headerlink" title="测量人脸的最可靠的方法"></a>测量人脸的最可靠的方法</h5><p>如何测量人脸的数值呢？耳朵大小？鼻子长度？眼睛的颜色？</p><p>实际上，对于人脸这些信息很容易分辨，可是对于计算机，这些值没什么价值。实际上最准确的方法是让计算机自己找出他要收集的测量值。深度学习比人类更懂得哪些面部测量值比较重要。</p><p>所以，解决方案是训练一个深度卷积神经网络，训练让它为脸部生成128个测量值。</p><p>每次训练要观察三个不同的脸部图像：</p><ol><li><p>加载一张已知的人的面部训练图像</p></li><li><p>加载同一个人的另一张照片</p></li><li><p>加载另外一个人的照片</p></li></ol><p>然后，算法查看它自己为这三个图片生成的测量值。再然后，稍微调整神经网络，以确保第一张和第二张生成的测量值接近，而第二张和第三张生成的测量值略有不同。</p><p>我们要不断的调整样本，重复以上步骤百万次，这确实是个巨大的挑战，但是一旦训练完成，它能攻轻松的找出人脸。</p><p>庆幸的是 <a href="http://cmusatyalab.github.io/openface/" target="_blank" rel="noopener">OpenFace</a> 上面的大神已经做完了这些，并且他们<a href="http://github.com/cmusatyalab/openface/tree/master/models/openface" target="_blank" rel="noopener">发布了几个训练过可以直接使用的网络</a>，我们可以不用部署复杂的机器学习，开箱即用，感谢开源精神。</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/d_value_128.png" alt="d_value_128"></p><p>这128个测量值是什么鬼？</p><p>其实我们不用关心，这对我们也不重要。我们关心的是，当看到同一个人的两张不同照片时，我们的网络需要能得到几乎相同的数值。</p><h4 id="第四部：从编码中找出人的名字"><a href="#第四部：从编码中找出人的名字" class="headerlink" title="第四部：从编码中找出人的名字"></a>第四部：从编码中找出人的名字</h4><p>最后一步实际上是最简单的一步，我们需要做的是找到数据库中与我们的测试图像的测量值最接近的那个人。</p><p>如何做呢，我们利用一些现成的数学公式，计算两个128D数值的<a href="https://en.wikipedia.org/wiki/Euclidean_distance" target="_blank" rel="noopener">欧氏距离</a><br><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/euclidean_distance.png" alt="euclidean_distance"></p><p>哈，这样我们得到一个欧式距离值，系统将给它一个认为是同一个人欧氏距离的阀值，即超过这个阀值我们就认定他们是 <strong>同 (失) 一 (散) 个 (兄) 人 (弟)</strong>。</p><p>人脸识别就这样达成啦，来来我们再回顾下流程：</p><ol><li>使用HOG找出图片中所有人脸的位置。</li><li>计算出人脸的68个特征点并适当的调整人脸位置，对齐人脸。</li><li>把上一步得到的面部图像放入神经网络，得到128个特征测量值，并保存它们。</li><li>与我们以前保存过的测量值一并计算欧氏距离，得到欧氏距离值，比较数值大小，即可得到是否同一个人。</li></ol><h2 id="人脸识别应用场景"><a href="#人脸识别应用场景" class="headerlink" title="人脸识别应用场景"></a>人脸识别应用场景</h2><p>人脸识别分两大步骤，人脸检测和人脸识别，它们应用场景也各不相同。</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/Face-Tracking-Android-Application-Structure.jpg" alt="Face-Tracking-Android-Application-Structure"></p><p>人脸检测目的是找出人脸，得到人脸的位置，我们可以在美颜，换肤，抠图，换脸 的一些场景中使用到它。我们可以通过系统API调用相机完成对预览针的实时渲染，那些看上去的黑科技我们也可以玩啦。<br><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/change_face.jpg" alt="change_face"></p><p>而人脸识别则可以在会员，支付等场景中使用，带给用户更酷的使用场景，快来试试吧。</p><p><br><br><br><br><br><br><br></p><p>引用：</p><p><a href="https://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework</a><br><a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x68;&#x74;&#116;&#112;&#x73;&#58;&#x2f;&#47;&#109;&#x65;&#100;&#105;&#117;&#109;&#46;&#99;&#111;&#109;&#x2f;&#x40;&#x61;&#x67;&#x65;&#105;&#x74;&#103;&#x65;&#x79;&#47;&#109;&#97;&#99;&#104;&#x69;&#110;&#101;&#x2d;&#108;&#x65;&#x61;&#114;&#x6e;&#x69;&#110;&#x67;&#x2d;&#x69;&#x73;&#45;&#x66;&#x75;&#110;&#45;&#x70;&#x61;&#x72;&#116;&#x2d;&#52;&#45;&#109;&#111;&#100;&#101;&#114;&#110;&#45;&#102;&#97;&#99;&#x65;&#45;&#114;&#101;&#x63;&#x6f;&#103;&#x6e;&#x69;&#x74;&#x69;&#111;&#x6e;&#x2d;&#x77;&#105;&#116;&#104;&#45;&#x64;&#101;&#101;&#x70;&#45;&#x6c;&#101;&#x61;&#114;&#110;&#105;&#x6e;&#x67;&#45;&#99;&#x33;&#x63;&#x66;&#102;&#99;&#49;&#50;&#49;&#x64;&#x37;">&#x68;&#x74;&#116;&#112;&#x73;&#58;&#x2f;&#47;&#109;&#x65;&#100;&#105;&#117;&#109;&#46;&#99;&#111;&#109;&#x2f;&#x40;&#x61;&#x67;&#x65;&#105;&#x74;&#103;&#x65;&#x79;&#47;&#109;&#97;&#99;&#104;&#x69;&#110;&#101;&#x2d;&#108;&#x65;&#x61;&#114;&#x6e;&#x69;&#110;&#x67;&#x2d;&#x69;&#x73;&#45;&#x66;&#x75;&#110;&#45;&#x70;&#x61;&#x72;&#116;&#x2d;&#52;&#45;&#109;&#111;&#100;&#101;&#114;&#110;&#45;&#102;&#97;&#99;&#x65;&#45;&#114;&#101;&#x63;&#x6f;&#103;&#x6e;&#x69;&#x74;&#x69;&#111;&#x6e;&#x2d;&#x77;&#105;&#116;&#104;&#45;&#x64;&#101;&#101;&#x70;&#45;&#x6c;&#101;&#x61;&#114;&#110;&#105;&#x6e;&#x67;&#45;&#99;&#x33;&#x63;&#x66;&#102;&#99;&#49;&#50;&#49;&#x64;&#x37;</a><br><a href="https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients</a><br><a href="http://www.csc.kth.se/~vahidk/papers/KazemiCVPR14.pdf" target="_blank" rel="noopener">http://www.csc.kth.se/~vahidk/papers/KazemiCVPR14.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出人脸识别&quot;&gt;&lt;a href=&quot;#深入浅出人脸识别&quot; class=&quot;headerlink&quot; title=&quot;深入浅出人脸识别&quot;&gt;&lt;/a&gt;深入浅出人脸识别&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dx
      
    
    </summary>
    
    
      <category term="face recognition" scheme="http://dxyoo7.github.io/tags/face-recognition/"/>
    
  </entry>
  
  <entry>
    <title>Flax Layout Mark</title>
    <link href="http://dxyoo7.github.io/2017/07/27/mark-flax-layout/"/>
    <id>http://dxyoo7.github.io/2017/07/27/mark-flax-layout/</id>
    <published>2017-07-27T08:27:10.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Flax Layout，发现几张图能轻松记住Flax的布局问题，顺便 Mark 下吧：</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/flax_layout_header.jpg" alt="flax_layout_header"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，</span></span><br><span class="line"><span class="comment">//还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。</span></span><br><span class="line"> </span><br><span class="line">flaxDirection:</span><br><span class="line"><span class="string">'row'</span>,           <span class="comment">//横向布局</span></span><br><span class="line"><span class="string">'column'</span>,        <span class="comment">//纵向布局</span></span><br><span class="line"><span class="string">'row-reverse'</span>,   <span class="comment">//横向反转（从又至左)</span></span><br><span class="line"><span class="string">'column-reverse'</span> <span class="comment">//纵向反转（从下至上)</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/flax_layout_direction.jpg" alt="flax_layout_direction"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。</span></span><br><span class="line"><span class="comment">//子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？</span></span><br><span class="line"></span><br><span class="line">justifyContent:<span class="comment">//Flax Direction 有这些属性可选</span></span><br><span class="line"><span class="string">'flex-start'</span>,           <span class="comment">//从主轴起始位置开始布局（左 或 上)</span></span><br><span class="line"><span class="string">'center'</span>,               <span class="comment">//主轴居中显示</span></span><br><span class="line"><span class="string">'flex-end'</span>,             <span class="comment">//从主轴结束位置开始布局 (右 或 下)</span></span><br><span class="line"><span class="string">'space-around‘          //平分主轴</span></span><br><span class="line"><span class="string">'</span>space-between<span class="string">'         //间隙平分</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/flax_layout_justfy_content.jpg" alt="flax_layout_justfy_content"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在组件的style中指定alignItems可以决定其子元素沿着次轴</span></span><br><span class="line"><span class="comment">//（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。</span></span><br><span class="line"><span class="comment">//子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？</span></span><br><span class="line">alignItem:  <span class="comment">//有这些属性</span></span><br><span class="line">‘flex-start’,</span><br><span class="line"><span class="string">'center'</span>,</span><br><span class="line"><span class="string">'flex-end'</span>,</span><br><span class="line"><span class="string">'stretch'</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/flax_layout_align_item.jpg" alt="flax_layout_align_item"></p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/flax_layout_flax_wrap.jpg" alt="flax_layout_flax_wrap"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习Flax Layout，发现几张图能轻松记住Flax的布局问题，顺便 Mark 下吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/flax_lay
      
    
    </summary>
    
    
      <category term="fount" scheme="http://dxyoo7.github.io/tags/fount/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出TCP/IP协议栈</title>
    <link href="http://dxyoo7.github.io/2017/07/21/u-should-know-protocol-of-tcp-ip/"/>
    <id>http://dxyoo7.github.io/2017/07/21/u-should-know-protocol-of-tcp-ip/</id>
    <published>2017-07-21T03:37:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「转」深入浅出TCP-IP协议栈"><a href="#「转」深入浅出TCP-IP协议栈" class="headerlink" title="「转」深入浅出TCP/IP协议栈"></a>「转」深入浅出TCP/IP协议栈</h1><p>TCP/IP协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP协议采用4层结构，分别是<strong>应用层、传输层、网络层和链路层</strong>，每一层都呼叫它的下一层所提供的协议来完成自己的需求。由于我们大部分时间都工作在应用层，下层的事情不用我们操心；其次网络协议体系本身就很复杂庞大，入门门槛高，因此很难搞清楚TCP/IP的工作原理，通俗一点讲就是，<strong>一个主机的数据要经过哪些过程才能发送到对方的主机上</strong>。 那我们就来探索一下这个过程：</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/tcp_ip_header.jpg" alt="tcp_ip_header"></p><h2 id="0、物理介质"><a href="#0、物理介质" class="headerlink" title="0、物理介质"></a>0、物理介质</h2><p>物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号(0和1)的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。</p><p>TCP/IP协议栈分为四层，每一层都由特定的协议与对方进行通信，而<strong>协议之间的通信最终都要转化为0和1的电信号，通过物理介质进行传输才能到达对方的电脑</strong>，因此物理介质是网络通信的基石。网络通信就像送快递一样，用户买的商品被一层层包裹就是各种协议，协议描述了商品的大小、收件人、联系方式以及配送地址，而实际的配送交通工具就是物理介质。其次对于一些偏远的地方，快递是不能直达的，需要中途转发，这时候快递上的各种协议就起作用了，它记录了要转发的地址、揽件人信息等，这就是TCP/IP搞这么多协议的作用。下面我们通过一张图先来大概了解一下TCP/IP协议的数据流：</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/tcp_ip_layer.jpg" alt="tcp_ip_layer"></p><p>当用户通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成<strong>以太网数据包</strong>，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。</p><p>有了整体概念以后，下面就详细讲一下其每一层的分工以及对应的协议：</p><h2 id="1、链路层"><a href="#1、链路层" class="headerlink" title="1、链路层"></a>1、链路层</h2><p>网络通信就是把有特定意义的数据通过物理介质传送给对方，单纯的发送0和1是没有意义的，因此就需要对0和1进行分组，并且要标识好每一组电信号的信息特征，然后按照分组的顺序依次发送。以太网规定一组电信号就是一个数据包，一个数据包被称为一帧， 制定这个规则的协议就是<strong>以太网协议</strong>。一个完整的以太网数据包如下图所示：</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/tcp_ip_lay_link_header.jpg" alt="tcp_ip_lay_link_header"></p><p>整个数据帧由<strong>首部、数据和尾部</strong>三部分组成，首部固定为14个字节，包含了目标MAC地址、源MAC地址和类型；数据最短为46个字节，最长为1500个字节，如果需要传输的数据很长，就必须分割成多个帧进行发送；尾部固定为4个字节，表示数据帧校验序列，用于确定数据包在传输过程中是否损坏。因此，以太网协议通过对电信号进行分组并形成数据帧，然后通过物理介质把数据帧发送给接收方。那么以太网如何来识接收方的身份呢？</p><p>以太网规协议定，接入网络的设备都必须安装网络适配器，即<strong>网卡</strong>， 数据包必须是从一块网卡传送到另一块网卡。而<strong>网卡地址</strong>就是数据包的发送地址和接收地址，也就是帧首部所包含的<strong>MAC地址</strong>，MAC地址是每块网卡的身份标识，就如同我们身份证上的身份证号码，具有全球唯一性。MAC地址采用十六进制标识，共6个字节， 前三个字节是厂商编号，后三个字节是网卡流水号，例如 <strong>4C-0F-6E-12-D2-19</strong></p><p>有了MAC地址以后，以太网采用<strong>广播</strong>形式，把数据包发给该<strong>子网内</strong>所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的<strong>目标MAC地址</strong>，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。</p><p>所以链路层的主要工作就是对<strong>电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</strong></p><h2 id="2、网络层"><a href="#2、网络层" class="headerlink" title="2、网络层"></a>2、网络层</h2><p>对于上面的过程，有几个细节问题值得我们思考：</p><ul><li>发送者如何知道接收者的MAC地址？</li><li>发送者如何知道接收者和自己同属一个子网？</li><li>如果接收者和自己不在同一个子网，数据包如何发给对方？</li></ul><p>为了解决这些问题，网络层引入了三个协议，分别是<strong>IP协议、ARP协议、路由协议。</strong></p><p>###【1】IP协议</p><p>通过前面的介绍我们知道，MAC地址只与厂商有关，与所处的网络无关，所以无法通过MAC地址来判断两台主机是否属于同一个子网。</p><p>因此，网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。</p><p>IP地址目前有两个版本，分别是IPv4和IPv6，IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。由于各类地址的分法不尽相同，以C类地址192.168.24.1为例，其中前24位就是网络地址，后8位就是主机地址。因此， 如果两个IP地址在同一个子网内，则网络地址一定相同。为了判断IP地址中的网络地址，IP协议还引入了子网掩码， IP地址和子网掩码通过按位与运算后就可以得到网络地址。</p><p>由于发送者和接收者的IP地址是已知的(应用层的协议会传入)， 因此我们只要通过子网掩码对两个IP地址进行AND运算后就能够判断双方是否在同一个子网了。</p><p>###【2】ARP协议</p><p>即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下：</p><p>ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。cmd输入 arp -a 就可以查询本机缓存的ARP数据。</p><p>###【3】路由协议</p><p>通过ARP协议的工作原理可以发现，ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议，首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。</p><p>而完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。</p><p>###【4】IP数据包</p><p>在网络层被包装的数据包就叫IP数据包，IPv4数据包的结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/tcp_ip_lay_ip_header.jpg" alt="tcp_ip_lay_ip_header"></p><p>IP数据包由首部和数据两部分组成，首部长度为20个字节，主要包含了目标IP地址和源IP地址，目标IP地址是网关路由的线索和依据；数据部分的最大长度为65515字节，理论上一个IP数据包的总长度可以达到65535个字节，而以太网数据包的最大长度是1500个字符，如果超过这个大小，就需要对IP数据包进行分割，分成多帧发送。</p><p>所以，网络层的主要工作是定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由。</p><h2 id="3、传输层"><a href="#3、传输层" class="headerlink" title="3、传输层"></a>3、传输层</h2><p>链路层定义了主机的身份，即MAC地址， 而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。</p><p>因此传输层引入了UDP协议来解决这个问题，为了给每个应用程序标识身份，UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。 这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP定义的数据包就叫做UDP数据包，结构如下所示：</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/tcp_ip_lay_transport_header.jpg" alt="tcp_ip_lay_transport_header"></p><p>UDP数据包由首部和数据两部分组成，首部长度为8个字节，主要包括源端口和目标端口；数据最大为65527个字节，整个数据包的长度最大可达到65535个字节。</p><p>UDP协议比较简单，实现容易，但它没有确认机制， 数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了，TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。</p><p>为了保证传输的可靠性，TCP协议在UDP基础之上建立了三次对话的确认机制，也就是说，在正式收发数据前，必须和对方建立可靠的连接。由于建立过程较为复杂，我们在这里做一个形象的描述：</p><ul><li>主机A：我想发数据给你，可以么？</li><li>主机B：可以，你什么时候发？</li><li>主机A：我马上发，你接着！</li></ul><p>经过三次对话之后，主机A才会向主机B发送正式数据，而UDP是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发过去了。所以TCP能够保证数据包在传输过程中不被丢失，但美好的事物必然是要付出代价的，相比UDP，TCP实现过程复杂，消耗连接资源多，传输速度慢。</p><p>TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><p>总结一下，传输层的主要工作是<strong>定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性</strong>。</p><h2 id="4、应用层"><a href="#4、应用层" class="headerlink" title="4、应用层"></a>4、应用层</h2><p>理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差，因此，应用层定义了各种各样的协议来规范数据格式，常见的有http,ftp,smtp等，http是一种比较常用的应用层协议，主要用于B/S架构之间的数据通信，其报文格式如下：</p><p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/resources/tcp_ip_cap_packet.jpg" alt="tcp_ip_cap_packet"></p><p>在请求Header中，分别定义了请求数据格式Accept 和 响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理，最后按照请求方要求的格式将数据返回，请求端接收到响应后，就按照规定的格式进行解读。</p><p>所以应用层的主要工作就是<strong>定义数据格式并按照对应的格式解读数据</strong>。</p><h2 id="5、全流程"><a href="#5、全流程" class="headerlink" title="5、全流程"></a>5、全流程</h2><p>首先我们梳理一下每层模型的职责：</p><ul><li><strong>链路层</strong>：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；</li><li><strong>网络层</strong>：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；</li><li><strong>传输层</strong>：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；</li><li><strong>应用层</strong>：定义数据格式，并按照对应的格式解读数据。</li></ul><p>然后再把每层模型的职责串联起来，用一句通俗易懂的话讲就是：</p><p>当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。</p><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>以上内容是对TCP/IP四层模型做了简单的介绍，而实际上每一层模型都有很多协议，每个协议要做的事情也很多，但我们首先得有一个清晰的脉络结构，掌握每一层模型最基本的作用，然后再去丰富细枝末节的东西，也许会更容易理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;「转」深入浅出TCP-IP协议栈&quot;&gt;&lt;a href=&quot;#「转」深入浅出TCP-IP协议栈&quot; class=&quot;headerlink&quot; title=&quot;「转」深入浅出TCP/IP协议栈&quot;&gt;&lt;/a&gt;「转」深入浅出TCP/IP协议栈&lt;/h1&gt;&lt;p&gt;TCP/IP协议栈是一系列网
      
    
    </summary>
    
    
      <category term="Net" scheme="http://dxyoo7.github.io/tags/Net/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符集编码入门（六）Java中的增补字符</title>
    <link href="http://dxyoo7.github.io/2017/03/13/java_6_surrogates_charset/"/>
    <id>http://dxyoo7.github.io/2017/03/13/java_6_surrogates_charset/</id>
    <published>2017-03-13T06:54:00.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的字符集编码入门（六）Java中的增补字符"><a href="#Java中的字符集编码入门（六）Java中的增补字符" class="headerlink" title="Java中的字符集编码入门（六）Java中的增补字符"></a>Java中的字符集编码入门（六）Java中的增补字符</h2><p>Java号称对Unicode提供天然的支持，这话在很久很久以前就已经是假的了（不过曾经是真的），实际上，到JDK5.0为止，Java才算刚刚跟上Unicode的脚步，开始提供对增补字符的支持。</p><p>现在的Unicode码空间为U+0000到U+10FFFF，一共1114112个码位，其中只有1，112，064 个码位是合法的（我来替你做算术，有2048个码位不合法），但并不是说现在的Unicode就有这么多个字符了，实际上其中很多码位还是空闲的，到Unicode 4.0 规范为止，只有96，382个码位被分配了字符（但无论如何，仍比很多人认为的65536个字符要多得多了）。其中U+0000 到U+FFFF的部分被称为基本多语言面（Basic Multilingual Plane，BMP）。U+10000及以上的字符称为补充字符。在Java中（Java1.5之后），补充字符使用两个char型变量来表示，这两个char型变量就组成了所谓的surrogate pair（在底层实际上是使用一个int进行表示的）。第一个char型变量的范围称为“高代理部分”（high-surrogates range，从”uD800到”uDBFF，共1024个码位）， 第二个char型变量的范围称为low-surrogates range（从”uDC00到”uDFFF，共1024个码位），这样使用surrogate pair可以表示的字符数一共是1024的平方计1048576个，加上BMP的65536个码位，去掉2048个非法的码位，正好是1，112，064个码位。</p><p>关于Unicode的码空间实际上有一些稍不小心就会让人犯错的地方。比如我们都知道从U+0000到U+FFFF的部分被称为基本多语言面（Basic Multilingual Plane，BMP），这个范围内的字符在使用UTF-16编码时，只需要一个char型变量就可以保存。仔细看看这个范围，应该有65536这么大，因此你会说单字节的UTF-16编码能够表示65536个字符，你也会说Unicode的基本多语言面包含65536个字符，但是再想想刚才说过的surrogate pair，一个UTF-16表示的增补字符（再一次的，需要两个char型变量才能表示的字符）怎样才能被正确的识别为增补字符，而不是两个普通的字符呢？答案你也知道，就是通过看它的第一个char是不是在高代理范围内，第二个char是不是在低代理范围内来决定，这也意味着，高代理和低代理所占的共2048个码位（从0xD800到0xDFFF）是不能分配给其他字符的。</p><p>但这是对UTF-16这种编码方法而言，而对Unicode这样的字符集呢？在Unicode的编号中，U+D800到U+DFFF是否有字符分配？答案是也没有！这是典型的字符集为方便编码方法而做的安排（你问他们这么做的目的？当然是希望基本多语言面中的字符和一个char型的UTF-16编码的字符能够一一对应，少些麻烦，从中我们也能看出UTF-16与Unicode间很深的渊源与结合）。也就是说，无论Unicode还是UTF-16编码后的字符，在0x0000至0xFFFF这个范围内，只有63488个字符。这就好比最初的CPU被勉强拿来做多媒体应用，用得多了，CPU就不得不修正自己从硬件上对多媒体应用提供支持了。</p><p>尽管不情愿，但说到这里总还得扯扯相关的概念：代码点和代码单元。</p><p>代码点（Code Point）就是指Unicode中为字符分配的编号，一个字符只占一个代码点，例如我们说到字符“汉”，它的代码点是U+6C49.代码单元（Code Unit）则是针对编码方法而言，它指的是编码方法中对一个字符编码以后所占的最小存储单元。例如UTF-8中，代码单元是一个字节，因为一个字符可以被编码为1个，2个或者3个4个字节；在UTF-16中，代码单元变成了两个字节（就是一个char），因为一个字符可以被编码为1个或2个char（你找不到比一个char还小的UTF-16编码的字符，嘿嘿）。说得再罗嗦一点，一个字符，仅仅对应一个代码点，但却可能有多个代码单元（即可能被编码为2个char）。</p><p>以上概念绝非学术化的绕口令，这意味着当你想以一种统一的方式指定自己使用什么字符的时候，使用代码点（即你告诉你的程序，你要用Unicode中的第几个字符）总是比使用代码单元更好（因为这样做的话你还得区分情况，有时候提供一个16进制数字，有时候要提供两个）。</p><p>例如我们有一个增补字符？？？（哈哈，你看到了三个问号对吧？因为我的系统显示不出这个字符），它在Unicode中的编号是U+2F81A，当在程序中需要使用这个字符的时候，就可以这样来写：</p><pre><code>Java代码  收藏代码String s=String.valueOf(Character.toChars(0x2F81A));  char[]chars=s.toCharArray();  for(char c:chars){      System.out.format(&quot;%x&quot;,(short)c);  }</code></pre><p>后面的for循环把这个字符的UTF-16编码打印了出来，结果是d87edc1a注意到了吗？这个字符变成了两个char型变量，其中0xd87e就是高代理部分的值，0xdc1a就是低代理的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java中的字符集编码入门（六）Java中的增补字符&quot;&gt;&lt;a href=&quot;#Java中的字符集编码入门（六）Java中的增补字符&quot; class=&quot;headerlink&quot; title=&quot;Java中的字符集编码入门（六）Java中的增补字符&quot;&gt;&lt;/a&gt;Java中的字符
      
    
    </summary>
    
    
      <category term="CharEncoding" scheme="http://dxyoo7.github.io/tags/CharEncoding/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符集编码入门（五）Java代码中的字符编码转换</title>
    <link href="http://dxyoo7.github.io/2017/03/12/java_5_transform_charset/"/>
    <id>http://dxyoo7.github.io/2017/03/12/java_5_transform_charset/</id>
    <published>2017-03-12T03:37:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的字符集编码入门（五）Java代码中的字符编码转换"><a href="#Java中的字符集编码入门（五）Java代码中的字符编码转换" class="headerlink" title="Java中的字符集编码入门（五）Java代码中的字符编码转换"></a>Java中的字符集编码入门（五）Java代码中的字符编码转换</h2><p>如果你是JVM的设计者，让你来决定JVM中所有字符的表示形式，你会不会允许使用各种编码方式的字符并存？ </p><p>我想你的答案是不会，如果在内存中的Java字符可以以GB2312，UTF-16，BIG5等各种编码形式存在，那么对开发者来说，连进行最基本的字符串打印、连接等操作都会寸步难行。例如一个GB2312的字符串后面连接一个UTF-8的字符串，那么连接后的最终结果应该是什么编码的呢？你选哪一个都没有道理。</p><p>因此牢记下面这句话，这也是Java开发者的共同意志：在Java中，字符只以一种形式存在，那就是Unicode（注意到我们没有选择特定的编码，直接使用它们在字符集中的编号，这是统一的唯一方法）。</p><p>但“在Java中”到底是指在哪里呢？就是指在JVM中，在内存中，在你的代码里声明的每一个char，String类型的变量中。例如你在程序中这样写 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char han=&apos;汉&apos;;</span><br></pre></td></tr></table></figure><p>在内存的相应区域，这个字符就表示为0x6C49.可以用下面的代码证明一下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char han=&apos;汉&apos;;</span><br><span class="line">System.out.format(&quot;%x&quot;,(short)han);</span><br></pre></td></tr></table></figure><p>输出是：6c49反过来用Unicode编号来指定一个字符也可以，像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char han=0x6c49;</span><br><span class="line">System.out.println(han);</span><br></pre></td></tr></table></figure><p>输出是：汉 </p><p>这其实也是说，只要你正确的读入了“汉”这个字，那么它在内存中的表示形式一定是0x6C49，没有任何其他的值能代表这个字（当然，如果你读错了，那结果是什么就不知道了，范伟说：读，读错了呀，那还等于好几亿呢；本山大哥说：好几亿你也没答上，请听下一题）。</p><p>JVM的这种约定使得一个字符存在的世界分为了两部分：JVM内部和OS的文件系统。在JVM内部，统一使用Unicode表示，当这个字符被从JVM内部移到外部（即保存为文件系统中的一个文件的内容时），就进行了编码转换，使用了具体的编码方案（也有一种很特殊的情况，使得在JVM内部也需要转换，不过这个是后话）。 </p><p>因此可以说，所有的编码转换就只发生在边界的地方，JVM和OS的交界处，也就是你的各种输入输出流（或者Reader，Writer类）起作用的地方。</p><p>话头扯到这里就必须接着说Java的IO系统。</p><p>尽管看上去混乱繁杂，但是所有的IO基本上可以分为两大阵营：面向字符的Reader啊Wrtier啊，以及面向字节的输入输出流。</p><p>下面我来逐一分解，其实一点也不难。<br>面向字符和面向字节中的所谓“面向”什么，是指这些类在处理输入输出的时候，在哪个意义上保持一致。如果是面向字节，那么这类工作要保证系统中的文件二进制内容和读入JVM内部的二进制内容要一致。不能变换任何0和1的顺序（也就是文件是怎么存的就怎么取，与文件保存的编码一致）。因此这是一种非常“忠实于原著”的做法（偶然间让我想起郭敬明抄袭庄羽的文章，那家伙，太忠实于原著了，笑）。</p><p>这种输入输出方式很适合读入视频文件或者音频文件，或者任何不需要做变换的文件内容。<br>而面向字符的IO是指希望系统中的文件的字符和读入内存的“字符”（注意和字节的区别）要一致。例如我们的中文版WindowsXP系统上有一个GBK的文本文件，其中有一个“汉”字，这个字的GBK编码是0xBABA（而Unicode编号是0x6C49），当我们使用面向字符的IO把它读入内存并保存在一个char型变量中时，我希望IO系统不要傻傻的直接把0xBABA放到这个char型变量中，我甚至都不关心这个char型变量具体的二进制内容到底是多少，我只希望这个字符读进来之后仍然是“汉”这个字。 </p><p>从这个意义上也可以看出，面向字符的IO类，也就是Reader和Writer类，实际上隐式的为我们做了编码转换，在输出时，将内存中的Unicode字符使用系统默认的编码方式进行了编码，而在输入时，将文件系统中已经编码过的字符使用默认编码方案进行了还原。我两次提到“默认”，是说Reader和Writer的聪明也仅此而已了，它们只会使用这个默认的编码来做转换，你不能为一个Reader或者Writer指定转换时使用的编码。这也意味着，如果你使用中文版WindowsXP系统，而上面存放了一个UTF-8编码的文件，当你使用Reader类来读入的时候，它会傻傻的使用GBK来做转换，转换后的内容当然驴唇不对马嘴！<br>    这种笨，有时候其实是一种傻瓜式的功能提供方式，对大多数初级用户（以及不需要跨平台的高级用户）来说反而是件好事。<br>    但我们不一样啦，我们都是国家栋梁，肩负着赶英超美的责任，必须师夷长技以治夷，所以我们总还要和GBK编码以外的文件打交道。<br>    说了上面这些内容，想必聪明的读者已经看出来，所谓编码转换就是一个字符与字节之间的转换，因此Java的IO系统中能够指定转换编码的地方，也就在字符与字节转换的地方，那就是（读者：InputStreamReader和OutputStreamWriter！作者：太强了，都会抢答了！）</p><p>PrintStream也可以对OutputStream进行包装并指定编码方式：PrintStream(OutputStream out,<br>boolean autoFlush, String encoding)，但实质上也是调用OutputStreamWriter来实现的。<br>System.err在eclipse中输出时是红色的字体。</p><p>这两个类是字节流和字符流之间的适配器类，因此他们肩负着编码转换的任务简直太自然啦！要注意，实际上也只能在这两类实例化的时候指定编码，是不是很好记呢？<br>下面来写一段小程序，来把“汉”字用我们非常崇拜的UTF-8编码写到文件中！ </p><figure class="highlight plain"><figcaption><span>收藏代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">    PrintWriter out = new PrintWriter(new OutputStreamWriter(  </span><br><span class="line">            new FileOutputStream(&quot;c:/utf-8.txt&quot;), &quot;UTF-8&quot;));  </span><br><span class="line">    try &#123;  </span><br><span class="line">        out.write(&quot;汉&quot;);  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">        out.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; catch (IOException e) &#123;  </span><br><span class="line">    throw new RuntimeException(e);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后到c盘下去找utf-8.txt这个文件，用UltraEdit打开，使用16进制查看，看到了什么？它的值是0xE6B189！噢耶！（读者：这，这有什么好高兴的……）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java中的字符集编码入门（五）Java代码中的字符编码转换&quot;&gt;&lt;a href=&quot;#Java中的字符集编码入门（五）Java代码中的字符编码转换&quot; class=&quot;headerlink&quot; title=&quot;Java中的字符集编码入门（五）Java代码中的字符编码转换&quot;&gt;
      
    
    </summary>
    
    
      <category term="CharEncoding" scheme="http://dxyoo7.github.io/tags/CharEncoding/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符集编码入门（四）网页文件的编码</title>
    <link href="http://dxyoo7.github.io/2017/03/11/java_4_website_encoding/"/>
    <id>http://dxyoo7.github.io/2017/03/11/java_4_website_encoding/</id>
    <published>2017-03-11T02:40:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的字符集编码入门（四）网页文件的编码"><a href="#Java中的字符集编码入门（四）网页文件的编码" class="headerlink" title="Java中的字符集编码入门（四）网页文件的编码"></a>Java中的字符集编码入门（四）网页文件的编码</h2><p>一个网页要想在浏览器中能够正确显示，需要在三个地方保持编码的一致：网页文件，网页编码声明和浏览器编码设置。 </p><p>首先是网页文件本身的编码，即网页文件在被创建的时候使用什么编码来保存。这个完全取决于创建该网页的人员使用了什么编码保存，而进一步的取决于该人员使用的操作系统。例如我们使用的中文版WindowsXP系统，当你新建一个文本文件，写入一些内容，并按下ctrl+s进行保存的那一刻，操作系统就替你使用GBK编码将文件进行了保存（没有使用UTF-8，也没有使用UTF-16）。而使用了英文系统的人，系统会使用ISO-8859-1进行保存，这也意味着，在英文系统的文件中如果输入一个汉字，是无法进行保存的（当然，你甚至都无法输入）。 </p><p>一个在创建XML文件时（创建HTML的时候倒很少有人这么认为）常见的误解是以为只要在页面的encoding部分声明了UTF-8，则文件就会被保存为UTF-8格式。这实在是……怎么说呢，不能埋怨大家。实际上XML文件中encoding部分与HTML文件中的charset中一样，只是告诉“别人”（这个别人可能是浏览你的页面的人，可能是浏览器，也可能是处理你页面的程序，别人需要知道这个，因为除非你告诉他们，否则谁也猜不出你用了什么编码，仅通过文件的内容判断不出使用了什么编码，这是真的）这个文件使用了什么编码，唯独操作系统不会搭理，它仍然会按自己默认的编码方式保存文件（再一次的，在我们的中文WindowsXP系统中，使用GBK保存）。至于这个文件是不是真的是encoding或者charset所声明的那种编码保存的呢？答案是不一定！ </p><p>例如新浪的页面就“声称”他是用GB2312编码保存的，但实际上却是GBK，也有无数的二把刀程序员用系统默认的GBK保存了他们的XML文件，却在他们的encoding中信誓旦旦的说是UTF-8的。 </p><p>这就是我们所说的第二个位置，网页编码声明中的编码应该与网页文件保存时使用的编码一致。 </p><p>而浏览器的编码设置实际上并不严格，就像我们第三节所说的那样，在浏览器中选择使用GB2312来查看，它实际上仍然会使用GBK进行。而且浏览器还有这样一种好习惯，即它会尽量猜测使用什么编码查看最合适。 </p><p>我要重申的是，网页文件的编码和网页文件中声明的编码保持一致，这是一个极好的建议（值得遵循，会与人方便，与己方便），但如果不一致，只要网页文件的编码与浏览器的编码设置一致，也是可以正确显示的。 </p><p>例如有这样一个页面，它使用GBK保存，但声明自己是UTF-8的。这个时候用浏览器打开它，首先会看到乱码，因为这个页面“告诉”浏览器用UTF-8显示，浏览器会很尊重这个提示，于是乱码一片。但当手工把浏览器设为GBK之后，显示正常。 </p><p>说了以上四节这么多，后面我们就来侃侃Java里的字符编码，你会发现有意思且挠头的事情很多，但一旦弄通，天下无敌（不过不要像东方不败那样才好）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java中的字符集编码入门（四）网页文件的编码&quot;&gt;&lt;a href=&quot;#Java中的字符集编码入门（四）网页文件的编码&quot; class=&quot;headerlink&quot; title=&quot;Java中的字符集编码入门（四）网页文件的编码&quot;&gt;&lt;/a&gt;Java中的字符集编码入门（四）网
      
    
    </summary>
    
    
      <category term="CharEncoding" scheme="http://dxyoo7.github.io/tags/CharEncoding/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符集编码入门（三）GB2312，GBK与中文网页</title>
    <link href="http://dxyoo7.github.io/2017/03/10/java_3_GB2312_GBK_chinese/"/>
    <id>http://dxyoo7.github.io/2017/03/10/java_3_GB2312_GBK_chinese/</id>
    <published>2017-03-10T04:01:09.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的字符集编码入门（三）GB2312，GBK与中文网页"><a href="#Java中的字符集编码入门（三）GB2312，GBK与中文网页" class="headerlink" title="Java中的字符集编码入门（三）GB2312，GBK与中文网页"></a>Java中的字符集编码入门（三）GB2312，GBK与中文网页</h2><p>GB2312是对中国的开发人员来说很重要的一个词汇，它的来龙去脉并不需要我在这里赘述，随便Goolge之便明白无误。我只是想提一句，记得前一节说到编码字符集和字符集编码不是一回事，而有的字符集编码又实际上没有做任何事，GB2312正是这样一种东西！ </p><p>GB2312最初指的是一个编码字符集，其中包含了ASCII所包含的英文字符，同时加入了6763个简体汉字以及其他一些ASCII之外的符号。与Unicode有UTF-8和UTF-16一样（当然， UTF-8和UTF-16也没有被限定只能用来对Unicode进行编码，实际上，你用它对视频进行编码都是可以的，只是编出的文件没有播放器支持罢了，哈哈），GB2312也有自己的编码方案，但这个方案直接使用一个字符在GB2312中的编号作为存储值（与UTF-32的做法类似），也因此，这个编码方案甚至没有正式的名称。我们日常说起GB2312的时候，常常即指这个字符集，也指这种编码方案。 </p><p>GBK是GB2312的后续标准，添加了更多的汉字和特殊符号，类似的是，GBK也是同时指他的字符集和他的编码。 </p><p>GBK还是现如今中文Windows操作系统的系统默认编码（这正是几乎所有网页上的，文件里的乱码问题的根源）。 </p><p>我们可以这样来验证，使用以下的Java代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String encoding=System.getProperty(&quot;file.encoding&quot;); </span><br><span class="line">System.out.println(encoding);</span><br></pre></td></tr></table></figure><p>输出结果为GBK （什么？你的输出不是这样？怎么可能？完了，我的牌子要砸了，等等，你用的繁体版XP？我说你这同志在这里捣什么乱？去！去！） </p><p>说到GB2312和GBK就不得不提中文网页的编码。尽管很多新开发的Web系统和新上线的注重国际化的网站都开始使用UTF-8，仍有相当一部分的中文媒体坚持使用GB2312和GBK，例如新浪的页面。其中有两点很值得注意。 </p><p>第一，页面中meta标签的部分，常常可以见到charset=GB2312这样的写法，很不幸的是，这个“charset”其实是用来指定页面使用的是什么字符集编码，而不是使用什么字符集。例如你见到过有人写“charset=UTF-8”，见到过有人写“charset=ISO-8859-1”，但你见过有人写“charset=Unicode”么？当然没有，因为Unicode是一个字符集，而不是编码。 </p><p>然而正是charset这个名称误导了很多程序员，真的以为这里要指定的是字符集，也因而使他们进一步的误以为UTF-8和UTF-16是一种字符集！（万恶啊）好在XML中已经做出了修改，这个位置改成了正确的名称：encoding.第二，页面中说的GB2312，实际上并不真的是GB2312（惊讶么？）。我们来做个实验，例如找一个GB2312中不存在的汉字“亸”（这个字确实不在GB2312中，你可以到GB2312的码表中去找，保证找不到），这个字在GBK中。然后你把它放到一个html页面中，试着在浏览器中打开它，然后选择浏览器的编码为“GB2312”，看到了什么？它完全正常显示！ </p><p>结论不用我说你也明白了，浏览器实际上使用的是GBK来显示。 </p><p>新浪的页面中也有很多这样的例子，到处都写charset=GB2312，却使用了无数个GB2312中并不存在的字符。这种做法对浏览器显示页面并不成问题，但在需要程序抓取页面并保存的时候带来了麻烦，程序将不能依据页面所“声称”的编码进行读取和保存，而只能尽量猜测正确的编码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java中的字符集编码入门（三）GB2312，GBK与中文网页&quot;&gt;&lt;a href=&quot;#Java中的字符集编码入门（三）GB2312，GBK与中文网页&quot; class=&quot;headerlink&quot; title=&quot;Java中的字符集编码入门（三）GB2312，GBK与中文网
      
    
    </summary>
    
    
      <category term="CharEncoding" scheme="http://dxyoo7.github.io/tags/CharEncoding/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符集编码入门(二) 编码字符集与字符集编码的区别</title>
    <link href="http://dxyoo7.github.io/2017/03/09/java_2_charset_and_encoding/"/>
    <id>http://dxyoo7.github.io/2017/03/09/java_2_charset_and_encoding/</id>
    <published>2017-03-09T01:22:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的字符集编码入门-二-编码字符集与字符集编码的区别"><a href="#Java中的字符集编码入门-二-编码字符集与字符集编码的区别" class="headerlink" title="Java中的字符集编码入门(二) 编码字符集与字符集编码的区别"></a>Java中的字符集编码入门(二) 编码字符集与字符集编码的区别</h2><p>需要再一次强调的是，无论历史上的UCS还是现如今的Unicode，两者指的都是编码字符集，而不是字符集编码。花费一点时间来理解好这件事，然后你会发现对所有网页的，系统的，编码标准之间的来回转换等等繁杂事务都会思路清晰，手到擒来。 </p><p>首先说说最一般意义上的字符集。 </p><p>一个抽象字符集其实就是指字符的集合，例如所有的英文字母是一个抽象字符集，所有的汉字是一个抽象字符集，当然，把全世界所有语言的符号都放在一起，也可以称为一个抽象字符集，所以这个划分是相当人为的。之所以说“抽象”二字，是因为这里所提及的字符不是任何具体形式的字符，拿汉字中的“汉”这个字符来说，您在这篇文章中看到的这个“汉”其实是这个字符的一种具体表现形式，是它的图像表现形式，而且它是用中文（而非拼音）书写而成，使用宋体外观；而当人们用嘴发出“汉”这个音的时候，他们是在使用“汉”的另一种具体表现形式——声音，但无论如何，两者所指的字符都是“汉”这个字。同一个字符的表现形式可能有无数种（点阵表示，矢量表示，音频表示，楷体，草书等等等等），把每一种表现形式下的同一个字符都纳入到字符集中，会使得集合过于庞大，冗余高，也不好管理。因此抽象字符集中的字符，都是指唯一存在的抽象字符，而忽略它的具体表现形式。 </p><p>抽象字符集中的诸多字符，没有顺序之分，谁也不能说哪个字符在哪个字符前面，而且这种抽象字符只有人能理解。在给一个抽象字符集合中的每个字符都分配一个整数编号之后（注意这个整数并没有要求大小），这个字符集就有了顺序，就成为了编码字符集。同时，通过这个编号，可以唯一确定到底指的是哪一个字符。当然，对于同一个字符，不同的字符集编码系统所制定的整数编号也不尽相同，例如“儿”这个字，在Unicode中，它的编号是0x513F，（为方便起见，以十六进制表示，但这个整数编号并不要求必须是以十六进制表示）意思是说它是Unicode这个编码字符集中的第0x513F个字符。而在另一种编码字符集比如Big5中，这个字就是第0xA449个字符了。这种情况的另一面是，许多字符在不同的编码字符集中被分配了相同的整数编号，例如英文字母“A”，在ASCII及Unicode中，均是第0x41个字符。我们常说的Unicode字符集，指的就是这种被分配了整数编号的字符集合，但要澄清的是，编码字符集中字符被分配的整数编号，不一定就是该字符在计算机中存储时所使用的值，计算机中存储的字符到底使用什么二进制整数值来表示，是由下面将要说到的字符集编码决定的。 字符集编码决定了如何将一个字符的整数编号对应到一个二进制的整数值，有的编码方案简单的将该整数值直接作为其在计算机中的表示而存储，例如英文字符就是这样，几乎所有的字符集编码方案中，英文字母的整数编号与其在计算机内部存储的二进制形式都一致。但有的编码方案，例如适用于Unicode字符集的UTF-8编码形式，就将很大一部分字符的整数编号作了变换后存储在计算机中。以“汉”字为例，“汉”的Unicode值为0x6C49，但其编码为UTF-8格式后的值为0xE6B189（注意到变成了三个字节）。我们经常听说的另一种编码方案UTF-16，则对Unicode中的前65536个字符编号都不做变换，直接作为计算机存储时使用的值（对65536以后的字符，仍然要做变换），例如“汉”字的Unicode编号为0x6C49，那么经过UTF-16编码后存储在计算机上时，它的表示仍为0x6C49！。我猜，正是因为UTF-16的存在，使得很多人认为Unicode是一种编码（实际上，是一个字符集，再次重申），也因此，很多人说Unicode的时候，他们实际上指的是UTF-16.UTF-16提供了surrogate pair机制，使得Unicode中码位大于65536的那些字符得以表示。 </p><p>Surrogate pair机制在目前来说实在不常用，甚至连一些UTF-16的实现都不支持，所以我不打算在这里多加讨论，其基本的思想就是用两个16位的编码表示一个字符（注意，只对码位超过65536的字符这么做）。Unicode如此死抱着16这个数字不放，有历史的原因，也有实用的原因。 </p><p>当然还有一种最强的编码，UTF-32，他对所有的Unicode字符均不做变换，直接使用编号存储！（俗称的以不变应万变），只是这种编码方案太浪费存储空间（就连1个字节就可以搞定的英文字符，它都必须使用4个字节），因而尽管使用起来方便（不需要任何转换），却没有得到普及。 </p><p>记得当初Unicode与UCS还没成家之时，UCS也是需要人爱，需要人疼的，没有自己的字符集编码怎么成。UCS-2与UCS-4就扮演了这样的角色。UCS-4与UTF-32除了名字不同以外，思想完全一样。而UCS-2与UTF-16在对前65536个字符的处理上也完全相同，唯一的区别只在于UCS-2 不支持surrogate pair机制，即是说，UCS-2只能对前65536个字符编码，对其后的字符毫无办法。不过现在再谈起字符编码的时候，UCS-2与UCS-4早已成为计算机史学家才会用到的词汇，就让它们继续留在故纸堆里吧。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java中的字符集编码入门-二-编码字符集与字符集编码的区别&quot;&gt;&lt;a href=&quot;#Java中的字符集编码入门-二-编码字符集与字符集编码的区别&quot; class=&quot;headerlink&quot; title=&quot;Java中的字符集编码入门(二) 编码字符集与字符集编码的区别&quot;
      
    
    </summary>
    
    
      <category term="CharEncoding" scheme="http://dxyoo7.github.io/tags/CharEncoding/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符集编码入门(一) Unicode与UCS的历史恩怨</title>
    <link href="http://dxyoo7.github.io/2017/03/08/java_1_unicode_and_ucs/"/>
    <id>http://dxyoo7.github.io/2017/03/08/java_1_unicode_and_ucs/</id>
    <published>2017-03-08T03:37:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的字符集编码入门-一-Unicode与UCS的历史恩怨"><a href="#Java中的字符集编码入门-一-Unicode与UCS的历史恩怨" class="headerlink" title="Java中的字符集编码入门(一) Unicode与UCS的历史恩怨"></a>Java中的字符集编码入门(一) Unicode与UCS的历史恩怨</h2><p>地球人都知道ASCII就是美国标准信息交换码的缩写，也知道ASCII规定用7位二进制数字来表示英文字符，ASCII被定为国际标准之后的代号为ISO-646.由于ASCII码只使用了7个二进制位，也就是说一个字节可以表示的256个数字中，它仅使用了0~127这128个码位，剩下的128个码位便可以用来做扩展，用来表示一些特定语言所独有的字符，因此对这多余的128个码位的不同扩展，就形成了一系列ISO-8859-*的标准。例如为英语作了专门扩展的字符集编码标准编号为ISO-8859-1，也叫做Latin-1，为希腊语所作的扩展编号为ISO-8859-7等，完整的列表可以参考《Java Internationalization》一书。 </p><p>整个Unicode项目是由多家计算机软件公司，还包括一些出版行业的公司共同发起的，从上世纪八十年代就已经开始。地球人都知道，对于日文，汉字来说，256个码位是远远不够用的（当然，在当时并不是地球人都知道，起码设计计算机的老美们就不知道，甚至直到今天，还有老美以为米国是世界上唯一的国家）。解决方法很直观也很明显，那就是采用码位多到足够包含所需字符数量的编码方案（即俗话说的头痛医头，脚痛医脚嘛）。这也是Unicode的目标之一，能够包含世界上所有语言的字符（包括汉字，日文，数学符号，音乐符号，还包括各种奇奇怪怪看也看不懂的东西比如象形文字，甲骨文 ，三个代表，科学发展观等等，笑），这个理想，可以说很远大，但很快被发现仅靠Unicode原先的设计无法实现。Unicode的另一个设计目标，对今天影响深远，那就是对所有字符都采用16位编码（即用一个大小不超过2的16次方的整数数字给每个字符编号，注意从这个意义上也可以看出，Unicode是一种编码字符集，而非字符集编码）。说这个设计目标对现今影响深远，完全不是表扬，因为到后来连Unicode的设计者也发现，16位编码仅有65536个码位，远远不能容纳世界上所有的字符，但当意识到这个问题的时候，Unicode大部分的规范已经制定完毕，也有相当程度的普及，完全推倒重来是不现实的。这成了一个遗留问题，也是surrogate pair这种蹩脚解决方案的发端。 </p><p>无独有偶，在1984年，喜欢以繁多的编号糊弄群众的国际标准化组织ISO也开始着手制定解决不同语言字符数量太大问题的解决方案，这一方案被称为Universal Character Set（UCS 统一字符集），正式的编号是ISO-10646（记得么，ASCII是ISO-646，不知这种安排是否是故意的）。还是ISO高瞻远瞩，一开始就确定了UCS是一个31位的编码字符集（即用一个大小不超过2的31次方的整数数字为每个字符编号），这回真的足以容纳古往今来所有国家，所有语言所包含的字符了（是的，任何国家，任何小语种都包括，也不管这些国家是与台湾建交还是与中国大陆建交，是拥护民主制度还是实行恐怖主义，所以说科学无国界）。虽然后来他们意识到，2的31次方个码位又实在太多了…… 天下大势，分久必合。无论Unicode还是UCS，最初的目的都是杜绝各种各样名目繁多形式各异互不兼容老死不相往来的私用扩展编码（好啰嗦的一句话），结果两方确立标准的同时（最初时这两个标准是不兼容的），又形成了割据，这对建设和谐社会是不利的，违反当今世界和平与发展的主旋律，中国政府一向反对任何形式的霸权主义和强权政治，对以米国为首的发达国家……扯远了扯远了。1991年，Unicode联盟与ISO的工作组终于开始讨论Unicode与UCS的合并问题，虽然其后的合并进行了很多年，Unicode初版规范中的很多编码都需要被改写，UCS也需要对码空间的使用进行必要限制，但成果是喜人的。最终，两者统一了抽象字符集（即任何一个在Unicode中存在的字符，在UCS中也存在），且最靠前的65535个字符也统一了字符的编码。对于码空间，两者同意以一百一十万为限（即两者都认为虽然65536不够，但2的31次方又太大，一百一十万是个双方都可接受的码空间大小，也够用，当然，这里说的一百一十万只是个约数），Unicode将码空间扩展到了一百一十万，而UCS将永久性的不使用一百一十万以后的码位。也就是说，现在再讲Unicode只包含65536个字符是不对的。除了对已经定义的字符进行统一外，Unicode联盟与ISO工作组也同意今后任何的扩展工作两者均保持同步，因此虽然从历史的意义上讲Unicode与UCS不是一回事（甚至细节上说也不是一回事），但现在提起Unicode，指代两者均无不妥。何的扩展工作两者均保持同步，因此虽然从历史的意义上讲Unicode与UCS不是一回事（甚至细节上说也不是一回事），但现在提起Unicode，指代两者均无不妥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java中的字符集编码入门-一-Unicode与UCS的历史恩怨&quot;&gt;&lt;a href=&quot;#Java中的字符集编码入门-一-Unicode与UCS的历史恩怨&quot; class=&quot;headerlink&quot; title=&quot;Java中的字符集编码入门(一) Unicode与UCS
      
    
    </summary>
    
    
      <category term="CharEncoding" scheme="http://dxyoo7.github.io/tags/CharEncoding/"/>
    
  </entry>
  
  <entry>
    <title>一个整型值益出的错误</title>
    <link href="http://dxyoo7.github.io/2017/02/21/a-mistake-about-overflow/"/>
    <id>http://dxyoo7.github.io/2017/02/21/a-mistake-about-overflow/</id>
    <published>2017-02-21T03:37:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个整型益处的错误，我觉得值得反思下，具体是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line">   int priority();//业务顺序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个乱序的arr = [obj_C, obj_B, obj_C, obj_A, obj_F, obj_D]，需要排序，于是默认使用了Comparator接口，通过他的compare(T lhs, T rhs)方法返回一个整型，整型的大小决定左右参数的排序，这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int compare(Obj lhs, Obj rhs) &#123;</span><br><span class="line">return lhs.proprity() - rhs.proprity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需求决定数组里面obj_A永远排在首位，于是为了简便我把 obj_A的类实现成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj_A = &#123;</span><br><span class="line">    int priority() &#123;</span><br><span class="line">        return Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似没啥问题，<code>obj_A.proprity() - obj_other().proprity</code>  值很小 或者 <code>obj_other().proprity － obj_A.proprity()</code> 值很大，排完序应该在第一位，可是事实却是永远排在最后一位。</p><p>事实上我遇到了整型益出的问题，Integer.MIN_VALUE - obj_other.proprity()，这样的计算会发生益出，得到的值很大, 并不是预期的值，同理也一样。</p><p>于是问题迎刃而解，只要给obj_A返回一个适当大小的负数即可，保证不会溢出。</p><blockquote><p>记录下：负数在电脑中是怎么相加的？</p></blockquote><p>答：<br>3的原码：0000 0011</p><p>3的反码：1111 1100</p><p>3的补码：    （即反码加1）<br>1111 1101</p><p>可以看出3的源码与反码相加为1111 1111为﹣127而与补码相加刚好为0000 0000为0这时补码就可以作为源码的负数表示正常的参与运算，在计算机中一般用加法代替减法，把要减的数换成补码再相加。负数加法也是一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇到一个整型益处的错误，我觉得值得反思下，具体是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Java" scheme="http://dxyoo7.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>StatusBar绘色控件</title>
    <link href="http://dxyoo7.github.io/2017/01/19/the_widget-draw_statbar-in-support-library/"/>
    <id>http://dxyoo7.github.io/2017/01/19/the_widget-draw_statbar-in-support-library/</id>
    <published>2017-01-19T03:37:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>support-design-v25.1.0 可绘制statusBar控件统计</p><p><code>DrawerLayout</code>: </p><ul><li>条件：apiLevel &gt;= 21; 布局里设置 fitSystemWindows=”true”</li><li>颜色：?attrs/colorPrimaryDark(默认); 布局里不提供属性；代码里提供setStatusBarBackground()等方法</li></ul><p><code>CoordinatorLayout</code>:</p><ul><li>条件：apiLevel &gt;= 21; 布局里设置 fitSystemWindows=”true”</li><li>颜色：?attrs/colorPrimaryDark(默认); 布局里提供属性statusBarBackground；代码里提供setStatusBarBackground()等方法。</li></ul><p><code>CollapsingToolbarLayout</code>:</p><ul><li>颜色：布局里提供statusBarScrim; 代码里提供setStatusBarScrim()</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;support-design-v25.1.0 可绘制statusBar控件统计&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DrawerLayout&lt;/code&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件：apiLevel &amp;gt;= 21; 布局里设置 fitSystemWindows=”tru
      
    
    </summary>
    
    
      <category term="CharEncoding" scheme="http://dxyoo7.github.io/tags/CharEncoding/"/>
    
  </entry>
  
  <entry>
    <title>Android中 MotionEvent MeasureSpec 位操作及含义</title>
    <link href="http://dxyoo7.github.io/2017/01/10/bit-operate-of-android/"/>
    <id>http://dxyoo7.github.io/2017/01/10/bit-operate-of-android/</id>
    <published>2017-01-10T03:37:54.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中为了节省内存，有很多变量使用位存储，例如MotionEvent.getAction()，下面我们来梳理下它们的含义和使用方法。</p><h2 id="MotionEvent-getAction"><a href="#MotionEvent-getAction" class="headerlink" title="MotionEvent.getAction();"></a>MotionEvent.getAction();</h2><p><code>MotionEvent.getAction()</code>得到是一个32位整型，现在可以告诉你有意义的是低16位。</p><p>1、低8位表示的是<code>action</code>动作, 例如0x00 代表 <code>ACTION_DOWN</code>。</p><p>2、高8位代表的是<code>point_index</code> 即 哪一个手指点击，例如0x0100 代表 第二个手指 <code>ACTION_DOWN</code>事件。</p><p>然后是一些常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_MASK = <span class="number">0xff</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_POINTER_INDEX_MASK = <span class="number">0xff00</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_POINTER_INDEX_SHIFT = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>看源码可知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nativeGetAction(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得Action动作 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getActionMasked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取低8位</span></span><br><span class="line">        <span class="keyword">return</span> nativeGetAction(mNativePtr) &amp; ACTION_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得触控点索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getActionIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取高8位，右移8位</span></span><br><span class="line">        <span class="keyword">return</span> (nativeGetAction(mNativePtr) &amp; ACTION_POINTER_INDEX_MASK) &gt;&gt; ACTION_POINTER_INDEX_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MeasureSpec-布局宽高存储"><a href="#MeasureSpec-布局宽高存储" class="headerlink" title="MeasureSpec 布局宽高存储"></a>MeasureSpec 布局宽高存储</h2><p>通常在自定义控件的时候我们都要重写 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 那这个MeasueSpec是个啥意思呢。</p><p><code>measureSpec</code>其实是父布局给子布局提供的宽高的容量，让子布局正确的计算出自己的宽高，<code>measureSpec</code>里面就携带了宽或高的参数，还有测量模式。</p><p><code>measureSpec</code>是一个32位整型，高2位代表的是 <code>MeasureMode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has not imposed any constraint</span></span><br><span class="line"><span class="comment"> * on the child. It can be whatever size it wants.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Measure specification mode: The parent has determined an exact size</span></span><br><span class="line"><span class="comment">  * for the child. The child is going to be given those bounds regardless</span></span><br><span class="line"><span class="comment">  * of how big it wants to be.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The child can be as large as it wants up</span></span><br><span class="line"><span class="comment"> * to the specified size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure><p>低30位代表宽或高的大小,看源码可知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据提供的测量值(格式)提取模式(上述三个模式之一)</span></span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据提供的测量值(格式)提取大小值(这个大小也就是我们通常所说的大小)</span></span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//根据提供的大小值和模式创建一个测量值(格式)</span></span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br>我们看到系统搞这么复杂的操作，往往我们使用几个变量就解决了，可是为啥系统要大费周章的使用位来存储呢？其实这正是系统的高明之处，我们知道计算机底层存储及通讯都是二机制位，而上层直接使用bit操作，可以减少内存的分配，试想下一个点击事件使用一个字节包含了所有的手势及触摸索引 比 你使用多个int存储节省多少内存呀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android中为了节省内存，有很多变量使用位存储，例如MotionEvent.getAction()，下面我们来梳理下它们的含义和使用方法。&lt;/p&gt;
&lt;h2 id=&quot;MotionEvent-getAction&quot;&gt;&lt;a href=&quot;#MotionEvent-getActi
      
    
    </summary>
    
    
      <category term="Android" scheme="http://dxyoo7.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>启用 Android_StrictMode</title>
    <link href="http://dxyoo7.github.io/2016/11/01/how-enable-strictmode/"/>
    <id>http://dxyoo7.github.io/2016/11/01/how-enable-strictmode/</id>
    <published>2016-11-01T09:21:31.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>##StrictMode 严格模式<br>StrictMode用来基于线程或VM设置一些策略, 一旦检测到策略违例, 控制台将输出一些警告，包含一个trace信息展示你的应用在何处出现问题.</p><p>通常用来检测主线程中的磁盘读写或网络访问等耗时操作.</p><p>在Application或是Activity的onCreate中开启StrictMode:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Constant.DEBUG) &#123;</span><br><span class="line"><span class="comment">// 针对线程的相关策略</span></span><br><span class="line">   StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">             .detectDiskReads()</span><br><span class="line">             .detectDiskWrites()</span><br><span class="line">             .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></span><br><span class="line">             .penaltyLog()</span><br><span class="line">             .build());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对VM的相关策略</span></span><br><span class="line">    StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</span><br><span class="line">              .detectLeakedSqlLiteObjects()</span><br><span class="line">              .detectLeakedClosableObjects()</span><br><span class="line">              .penaltyLog()</span><br><span class="line">              .penaltyDeath()</span><br><span class="line">              .build());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##StrictMode 严格模式&lt;br&gt;StrictMode用来基于线程或VM设置一些策略, 一旦检测到策略违例, 控制台将输出一些警告，包含一个trace信息展示你的应用在何处出现问题.&lt;/p&gt;
&lt;p&gt;通常用来检测主线程中的磁盘读写或网络访问等耗时操作.&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://dxyoo7.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java(Android) 约定规范</title>
    <link href="http://dxyoo7.github.io/2016/11/01/android_project_struct/"/>
    <id>http://dxyoo7.github.io/2016/11/01/android_project_struct/</id>
    <published>2016-11-01T09:21:31.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-项目指南"><a href="#1-项目指南" class="headerlink" title="1.项目指南"></a>1.项目指南</h1><h2 id="1-1项目结构"><a href="#1-1项目结构" class="headerlink" title="1.1项目结构"></a>1.1项目结构</h2><p>新项目应该遵循<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Project-Structure" target="_blank" rel="noopener">Android Gradle插件用户指南</a>中定义的Android Gradle项目结构。</p><h2 id="1-2文件命名"><a href="#1-2文件命名" class="headerlink" title="1.2文件命名"></a>1.2文件命名</h2><h3 id="1-2-1类命名"><a href="#1-2-1类命名" class="headerlink" title="1.2.1类命名"></a>1.2.1类命名</h3><p>类命名按 <strong>驼峰命名法 UpperCamelCase</strong> 规则书写.</p><p>对于继承自Android组件的类，应该以组件名结尾；比如：SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog.</p><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>资源文件按 <strong>小写_下划线</strong> 规则书写</p><h4 id="1-2-2-1-Drawable-文件"><a href="#1-2-2-1-Drawable-文件" class="headerlink" title="1.2.2.1 Drawable 文件"></a>1.2.2.1 Drawable 文件</h4><p>drawables 命名约定：</p><table><thead><tr><th>Asset Type</th><th>Prefix</th><th>Example</th></tr></thead><tbody><tr><td>Action bar</td><td><code>ab_</code></td><td><code>ab_stacked.9.png</code></td></tr><tr><td>Button</td><td><code>btn_</code></td><td><code>btn_send_pressed.9.png</code></td></tr><tr><td>Dialog</td><td><code>dialog_</code></td><td><code>dialog_top.9.png</code></td></tr><tr><td>Divider</td><td><code>divider_</code></td><td><code>divider_horizontal.9.png</code></td></tr><tr><td>Icon</td><td><code>ic_</code></td><td><code>ic_star.png</code></td></tr><tr><td>Menu</td><td><code>menu_</code></td><td><code>menu_submenu_bg.9.png</code></td></tr><tr><td>Notification</td><td><code>notification_</code></td><td><code>notification_bg.9.png</code></td></tr><tr><td>Tabs</td><td><code>tab_</code></td><td><code>tab_pressed.9.png</code></td></tr></tbody></table><p>icon的命名约定(取自<a href="http://developer.android.com/design/style/iconography.html" target="_blank" rel="noopener">Android iconography guidelines</a>):</p><table><thead><tr><th>Asset Type</th><th>Prefix</th><th>Example</th></tr></thead><tbody><tr><td>Icons</td><td><code>ic_</code></td><td><code>ic_star.png</code></td></tr><tr><td>Launcher icons</td><td><code>ic_launcher</code></td><td><code>ic_launcher_calendar.png</code></td></tr><tr><td>Menu icons and Action Bar icons</td><td><code>ic_menu</code></td><td><code>ic_menu_archive.png</code></td></tr><tr><td>Status bar icons</td><td><code>ic_stat_notify</code></td><td><code>ic_stat_notify_msg.png</code></td></tr><tr><td>Tab icons</td><td><code>ic_tab</code></td><td><code>ic_tab_recent.png</code></td></tr><tr><td>Dialog icons</td><td><code>ic_dialog</code></td><td><code>ic_dialog_info.png</code></td></tr></tbody></table><p>状态选择器(selector states)命名约定:</p><table><thead><tr><th>State</th><th>Suffix</th><th>Example</th></tr></thead><tbody><tr><td>Normal</td><td><code>_normal</code></td><td><code>btn_order_normal.9.png</code></td></tr><tr><td>Pressed</td><td><code>_pressed</code></td><td><code>btn_order_pressed.9.png</code></td></tr><tr><td>Focused</td><td><code>_focused</code></td><td><code>btn_order_focused.9.png</code></td></tr><tr><td>Disabled</td><td><code>_disabled</code></td><td><code>btn_order_disabled.9.png</code></td></tr><tr><td>Selected</td><td><code>_selected</code></td><td><code>btn_order_selected.9.png</code></td></tr></tbody></table><h4 id="1-2-2-2-layout-文件"><a href="#1-2-2-2-layout-文件" class="headerlink" title="1.2.2.2 layout 文件"></a>1.2.2.2 layout 文件</h4><p>布局文件应该与它们打算用于的Android组件的名称匹配，但将顶层组件名称移动到开头。 例如，如果我们为<code>SignInActivity</code>创建一个布局，布局文件的名称应该是<code>activity_sign_in.xml</code></p><table><thead><tr><th>Component</th><th>Class Name</th><th>Layout Name</th></tr></thead><tbody><tr><td>Activity</td><td><code>UserProfileActivity</code></td><td><code>activity_user_profile.xml</code></td></tr><tr><td>Fragment</td><td><code>SignUpFragment</code></td><td><code>fragment_sign_up.xml</code></td></tr><tr><td>Dialog</td><td><code>ChangePasswordDialog</code></td><td><code>dialog_change_password.xml</code></td></tr><tr><td>AdapterView item</td><td>—</td><td><code>item_person.xml</code></td></tr><tr><td>Partial layout</td><td>—</td><td><code>partial_stats_bar.xml</code></td></tr></tbody></table><p>一个稍微不同的情况是，当我们创建一个布局将被一个<code>Adapter</code>渲染，例如填充一个 <code>ListView</code>。 在这种情况下，布局的名称应以<code>item_</code>开头。</p><p>请注意，有些情况下，这些规则将无法应用。 例如，当创建旨在作为其他布局的一部分的布局文件时。 在这种情况下，您应该使用前缀<code>partial_</code>。</p><h4 id="1-2-2-3-Menu-文件"><a href="#1-2-2-3-Menu-文件" class="headerlink" title="1.2.2.3 Menu 文件"></a>1.2.2.3 Menu 文件</h4><p>与布局文件类似，Menu 文件应与组件的名称匹配。 例如，如果我们定义将要在<code>UserActivity</code>中使用的菜单文件，那么文件的名称应该是<code>activity_user.xml</code></p><p>一个好的做法是不要将“menu”一词作为名称的一部分，因为这些文件已经位于<code>menu</code>目录中。</p><h4 id="1-2-2-4-Values-文件"><a href="#1-2-2-4-Values-文件" class="headerlink" title="1.2.2.4 Values 文件"></a>1.2.2.4 Values 文件</h4><p>values文件夹中的资源文件应为 <strong>复数</strong> ，例如 <code>strings.xml</code>，<code>styles.xml</code>，<code>colors.xml</code>，<code>dimensions.xml</code>，<code>attrs.xml</code></p><h1 id="2-代码指南"><a href="#2-代码指南" class="headerlink" title="2 代码指南"></a>2 代码指南</h1><h2 id="2-1-Java-语法规则"><a href="#2-1-Java-语法规则" class="headerlink" title="2.1 Java 语法规则"></a>2.1 Java 语法规则</h2><h3 id="2-1-1-不要忽略异常"><a href="#2-1-1-不要忽略异常" class="headerlink" title="2.1.1 不要忽略异常"></a>2.1.1 不要忽略异常</h3><p>你永远不要这样做:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会认为：你的代码永远不会碰到这种出错的情况，或者处理异常并不重要，可类似上述忽略异常的代码将会在代码中埋下一颗地雷，说不定哪天它就会炸到某个人了。你必须在代码中以某种规矩来处理所有的异常。根据情况的不同，处理的方式也会不一样。</p><p><em>无论何时，空的catch语句都会让人感到不寒而栗。虽然很多情况下确实是一切正常，但至少你不得不去忧虑它。在Java中你无法逃离这种恐惧感。</em> -<a href="http://www.artima.com/intv/solid4.html" target="_blank" rel="noopener">James Gosling</a></p><p>可接受的替代方案包括（按照推荐顺序）：</p><ul><li>向方法的调用者抛出异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span><span class="params">(String value)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    serverPort = Integer.parseInt(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据抽象级别抛出新的异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span><span class="params">(String value)</span> <span class="keyword">throws</span> ConfigurationException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">"Port "</span> + value + <span class="string">" is not valid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默默地处理错误并在catch {}语句块中替换为合适的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Set port. If value is not a valid number, 80 is substituted. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        serverPort = <span class="number">80</span>;  <span class="comment">// default port for server</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>捕获异常并抛出一个新的RuntimeException。这种做法比较危险：只有确信发生该错误时最合适的做法就是崩溃，才会这么做。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Set port. If value is not a valid number, die. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"port "</span> + value <span class="string">" is invalid, "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请记住，最初的异常是传递给构造方法的RuntimeException。如果代码必须在Java 1.3版本下编译，需要忽略该异常</p></blockquote><ul><li>最后一招：如果确信忽略异常比较合适，那就忽略吧，但必须把理想的原因注释出来：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** If value is not a valid number, original port number is used. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// Method is documented to just ignore invalid user input.</span></span><br><span class="line">        <span class="comment">// serverPort will just be unchanged.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-不要捕获顶级的Exception"><a href="#2-1-2-不要捕获顶级的Exception" class="headerlink" title="2.1.2 不要捕获顶级的Exception"></a>2.1.2 不要捕获顶级的Exception</h3><p>有时在捕获Exception时偷懒也是很吸引人的，类似如下的处理方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    someComplicatedIOFunction();        <span class="comment">// may throw IOException</span></span><br><span class="line">    someComplicatedParsingFunction();   <span class="comment">// may throw ParsingException</span></span><br><span class="line">    someComplicatedSecurityFunction();  <span class="comment">// may throw SecurityException</span></span><br><span class="line">    <span class="comment">// phew, made it all the way</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;                 <span class="comment">// I'll just catch all exceptions</span></span><br><span class="line">    handleError();                      <span class="comment">// with one generic handler!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝大部分情况下，捕获顶级的Exception或Throwable都是不合适的，Throwable更不合适，因为它还包含了Error异常。这种捕获非常危险。这意味着本来不必考虑的Exception（包括类似ClassCastException的RuntimeException）被卷入到应用程序级的错误处理中来。这会让代码运行的错误变得模糊不清。这意味着，假如别人在你调用的代码中加入了新的异常，编译器将无法帮助你识别出各种不同的错误类型。绝大部分情况下，无论如何你都不应该用同一种方式来处理各种不同类型的异常。</p><p>本规则也有极少数例外情况：期望捕获所有类型错误的特定的测试代码和顶层代码（为了阻止这些错误在用户界面上显示出来，或者保持批量工作的运行）。这种情况下可以捕获顶级的Exception（或Throwable）并进行相应的错误处理。在开始之前，你应该非常仔细地考虑一下，并在注释中解释清楚为什么这么做是安全的。</p><p>比捕获顶级Exception更好的方案：</p><ul><li><p>分开捕获每一种异常，在一条try语句后面跟随多个catch 语句块。这样可能会有点别扭，但总比捕获所有Exception要好些。请小心别在catch语句块中重复执行大量的代码。</p></li><li><p>重新组织一下代码，使用多个try块，使错误处理的粒度更细一些。把IO从解析内容的代码中分离出来，根据各自的情况进行单独的错误处理。</p></li><li><p>再次抛出异常。很多时候在你这个级别根本就没必要捕获这个异常，只要让方法抛出该异常即可。</p></li></ul><p>请记住：异常是你的朋友！当编译器指出你没有捕获某个异常时，请不要皱眉头。而应该微笑：编译器帮助你找到了代码中的运行时（runtime）问题。</p><h3 id="2-1-3-不要使用-finalizers"><a href="#2-1-3-不要使用-finalizers" class="headerlink" title="2.1.3 不要使用 finalizers"></a>2.1.3 不要使用 finalizers</h3><p>Finalizer提供了一个机会，可以让对象被垃圾回收器回收时执行一些代码。</p><p>优点：便于执行清理工作，特别是针对外部资源。</p><p>缺点：调用finalizer的时机并不确定，甚至根本就不会调用。</p><p>结论：我们不要使用finalizers。大多数情况下，可以用优秀的异常处理代码来执行那些要放入finalizer的工作。如果确实是需要使用finalizer，那就定义一个close()方法（或类似的方法），并且在文档中准确地记录下需要调用该方法的时机。相关例程可以参见InputStream。这种情况下还是适合使用finalizer的，但不需要在finalizer中输出日志信息，因为日志不能因为这个而被撑爆。</p><h3 id="2-1-4-使用完全限定Import"><a href="#2-1-4-使用完全限定Import" class="headerlink" title="2.1.4 使用完全限定Import"></a>2.1.4 使用完全限定Import</h3><p>当需要使用foo包中的Bar类时，存在两种可能的import方式：</p><ul><li><p><code>import foo.*;</code></p><p> 有点：可能会减少import语句。</p></li><li><p><code>import foo.Bar;</code></p><p> 优点：实际用到的类一清二楚。代码的可读性更好，便于维护。</p></li></ul><p>结论：用后一种写法来<code>import</code>所有的Android代码。不过导入java标准库(<code>java.util.*</code>、<code>java.io.*</code>等) 和单元测试代码 (<code>junit.framework.*</code>)时可以例外。</p><h2 id="2-2-Java类库规范"><a href="#2-2-Java类库规范" class="headerlink" title="2.2 Java类库规范"></a>2.2 Java类库规范</h2><p>使用Android Java类库和工具存在一些惯例。有时这些惯例会作出重大变化，可之前的代码也许会用到过时的模板或类库。如果用到这部分过时的代码，沿用已有的风格就是了（参阅Consistency)。创建新的组件时就不要再使用过时的类库了。</p><h2 id="2-3-Java编程规范"><a href="#2-3-Java编程规范" class="headerlink" title="2.3 Java编程规范"></a>2.3 Java编程规范</h2><h3 id="2-3-1-使用Javadoc标准注释"><a href="#2-3-1-使用Javadoc标准注释" class="headerlink" title="2.3.1 使用Javadoc标准注释"></a>2.3.1 使用Javadoc标准注释</h3><p>每个文件的开头都应该有一句版权说明。然后下面应该是package包语句和import语句，每个语句块之间用空行分隔。然后是类或接口的定义。在Javadoc注释中，应描述类或接口的用途。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2015 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.android.internal.foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Blah;</span><br><span class="line"><span class="keyword">import</span> android.view.Yada;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Does X and Y and provides an abstraction for Z.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类和自建的public方法必须包含Javadoc注释，注释至少要包含描述该类或方法用途的语句。并且该语句应该用第三人称的动词形式来开头。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the correctly rounded positive square root of a double value. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new String by converting the specified array of</span></span><br><span class="line"><span class="comment"> * bytes using the platform's default character encoding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有的Javadoc都会写成“sets Foo”，对于那些无关紧要的类似setFoo()的get和set语句是不必撰写Javadoc的。如果方法执行了比较复杂的操作（比如执行强制约束或者产生很重要的副作用），那就必须进行注释。如果“Foo”属性的意义不容易理解，也应该进行注释。</p><p>无论是public的还是其它类型的，所有自建的方法都将受益于Javadoc。public的方法是API的组成部分，因此更需要Javadoc。</p><p>Android目前还没有规定自己的Javadoc注释撰写规范，但是应该遵守<a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html" target="_blank" rel="noopener">Sun Javadoc约定</a>。</p><h3 id="2-3-2-编写简短的方法"><a href="#2-3-2-编写简短的方法" class="headerlink" title="2.3.2 编写简短的方法"></a>2.3.2 编写简短的方法</h3><p>为了把规模控制在合理范围内，方法应该保持简短和重点突出。不过，有时较长的方法也是合适的，所以对方法的代码长度并没有硬性的限制。如果方法代码超过了40行，就该考虑是否可以在不损害程序结构的前提下进行分拆。</p><h3 id="2-3-4-在标准的位置定义字段"><a href="#2-3-4-在标准的位置定义字段" class="headerlink" title="2.3.4 在标准的位置定义字段"></a>2.3.4 在标准的位置定义字段</h3><p>字段应该定义在文件开头，或者紧挨着使用这些字段的方法之前。</p><h3 id="2-2-1-属性的定义你和命名"><a href="#2-2-1-属性的定义你和命名" class="headerlink" title="2.2.1 属性的定义你和命名"></a>2.2.1 属性的定义你和命名</h3><p>属性应该定义在 <strong>文件的顶部</strong> 并且他们应该遵循以下规则：</p><ul><li>Private （私有）, non-static（非静态）属性名以  <strong>m</strong> 开头.</li><li>Private （私有）, static（静态） 属性以 <strong>s</strong> 开头.</li><li>其它属性以小写字母开头.</li><li>final static (常量) 全部大写 ALL_CAPS_WITH_UNDERSCORES.</li></ul><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SOME_CONSTANT = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> publicField;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyClass sSingleton;</span><br><span class="line">    <span class="keyword">int</span> mPackagePrivate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mProtected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-将缩略词作为单词"><a href="#2-2-3-将缩略词作为单词" class="headerlink" title="2.2.3 将缩略词作为单词"></a>2.2.3 将缩略词作为单词</h3><table><thead><tr><th>Good</th><th>Bad</th></tr></thead><tbody><tr><td><code>XmlHttpRequest</code></td><td><code>XMLHTTPRequest</code></td></tr><tr><td><code>getCustomerId</code></td><td><code>getCustomerID</code></td></tr><tr><td><code>String url</code></td><td><code>String URL</code></td></tr><tr><td><code>long id</code></td><td><code>long ID</code></td></tr></tbody></table><h3 id="2-2-4-使用空格缩进"><a href="#2-2-4-使用空格缩进" class="headerlink" title="2.2.4 使用空格缩进"></a>2.2.4 使用空格缩进</h3><p>使用 <strong>4 个空格</strong> 缩进下面的代码块:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>8 个空格</strong> 行格式对齐缩进:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instrument i =</span><br><span class="line">        someLongExpression(that, wouldNotFit, on, one, line);</span><br></pre></td></tr></table></figure><h3 id="2-2-5-使用标准括号风格"><a href="#2-2-5-使用标准括号风格" class="headerlink" title="2.2.5 使用标准括号风格"></a>2.2.5 使用标准括号风格</h3><p>大括号与它们之前的代码在同一行上.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (something) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (somethingElse) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在语句周围括号，除非条件和body块适合一行。</p><p>如果条件和body块同一行，同时这行的长度小于最大行长，那么括号不不需要，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) body();</span><br></pre></td></tr></table></figure><p> <strong>不好的做法</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    body();  <span class="comment">// bad!</span></span><br></pre></td></tr></table></figure><h3 id="2-2-6-注解"><a href="#2-2-6-注解" class="headerlink" title="2.2.6 注解"></a>2.2.6 注解</h3><h4 id="2-2-6-1-注解实践"><a href="#2-2-6-1-注解实践" class="headerlink" title="2.2.6.1 注解实践"></a>2.2.6.1 注解实践</h4><p>根据 安卓代码风格指南，Java里面有些预定义注释的标准实践。</p><ul><li><p><code>@Deparected</code> 无论何时一个元素被标注废弃，必须使用 <code>@Deparected</code>. If you use the @Deprecated annotation, you must also have a @deprecated Javadoc tag and it should name an alternate implementation. In addition, remember that a @Deprecated method is still supposed to work. If you see old code that has a @deprecated Javadoc tag, please add the @Deprecated annotation.</p></li><li><p><code>@Override</code>: @Override 注解 <strong>必须使用</strong> , 当一个方法重载或实现它父类方法的时候. 例如, 如果使用一个 @inheritdocs Javadoc 标签, 从一个类（不是一个接口）派生，你还必须注释该方法@Overrides 父类的方法。</p></li><li><p><code>@SuppressWarnings</code>: The @SuppressWarnings annotation should only be used under circumstances where it is impossible to eliminate a warning. If a warning passes this “impossible to eliminate” test, the @SuppressWarnings annotation must be used, so as to ensure that all warnings reflect actual problems in the code.</p></li></ul><p>More information about annotation guidelines can be found <a href="http://source.android.com/source/code-style.html#use-standard-java-annotations" target="_blank" rel="noopener">here</a>.</p><h4 id="2-2-6-2-Annotations-style"><a href="#2-2-6-2-Annotations-style" class="headerlink" title="2.2.6.2 Annotations style"></a>2.2.6.2 Annotations style</h4><p><strong>Classes, Methods and Constructors</strong></p><p>When annotations are applied to a class, method, or constructor, they are listed after the documentation block and should appear as <strong>one annotation per line</strong> .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the documentation block about the class */</span></span><br><span class="line"><span class="meta">@AnnotationA</span></span><br><span class="line"><span class="meta">@AnnotationB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotatedClass</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>Fields</strong></p><p>Annotations applying to fields should be listed <strong>on the same line</strong>, unless the line reaches the maximum line length.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="meta">@Mock</span> DataManager mDataManager;</span><br></pre></td></tr></table></figure><h3 id="2-2-7-限制变量的作用范围"><a href="#2-2-7-限制变量的作用范围" class="headerlink" title="2.2.7 限制变量的作用范围"></a>2.2.7 限制变量的作用范围</h3><p>局部变量的作用范围应该是限制为最小的（Effective Java第29条）。使用局部变量，可以增加代码的可读性和可维护性，并且降低发生错误的可能性。每个变量都应该在最小范围的代码块中进行声明，该代码块的大小只要能够包含所有对该变量的使用即可。</p><p>应该在第一次用到局部变量的地方对其进行声明。几乎所有局部变量声明都应该进行初始化。如果还缺少足够的信息来正确地初始化变量，那就应该推迟声明，直至可以初始化为止 - (<a href="https://source.android.com/source/code-style.html#limit-variable-scope" target="_blank" rel="noopener">Android code style guidelines</a>)</p><h3 id="2-2-8-对Import语句排序"><a href="#2-2-8-对Import语句排序" class="headerlink" title="2.2.8 对Import语句排序"></a>2.2.8 对Import语句排序</h3><p>如果你使用IDE，比如Android Studio，你不用担心因为你的IDE已经遵守这些规则了。如果不是，请看下面。</p><p>import语句的次序应该如下：</p><ol><li>Android imports</li><li>Imports from third parties (com, junit, net, org)</li><li>java and javax</li><li>Same project imports</li></ol><p>为了精确匹配IDE的配置，import顺序应该是：</p><ul><li>在每组内部按字母排序，大写字母排在小写字母的前面。</li><li>每个大组之间应该空一行（android、com、junit、net、org、java、javax）。</li></ul><p>更多 <a href="https://source.android.com/source/code-style.html#limit-variable-scope" target="_blank" rel="noopener">点这</a></p><h3 id="2-2-9-Logging-使用"><a href="#2-2-9-Logging-使用" class="headerlink" title="2.2.9 Logging 使用"></a>2.2.9 Logging 使用</h3><p>使用<code>Log</code>类提供的方法来打印输出错误或者其它的信息，帮助我们定位问题。</p><ul><li><code>Log.v(String tag, String msg)</code> (verbose)</li><li><code>Log.d(String tag, String msg)</code> (debug)</li><li><code>Log.i(String tag, String msg)</code> (information)</li><li><code>Log.w(String tag, String msg)</code> (warning)</li><li><code>Log.e(String tag, String msg)</code> (error)</li></ul><p>一个通用的规则，我们使用 <code>static final</code> 类名定义tag。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyClass.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"My error message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VERBOSE 和 DEBUG 日志 <strong>必须</strong> 在release 版本中关掉。也推荐关掉 INFORMATION, WARNING and ERROR 级别的日志，但是你可能想要保持打开为了在release 版本中定位问题。如果你决定打开他们，你必须保证不要再日子里泄漏一些敏感的信息，比如email地址，用户id等。</p><p>只会在debug版本中显示的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BuildConfig.DEBUG) Log.d(TAG, <span class="string">"The value of x is "</span> + x);</span><br></pre></td></tr></table></figure><h3 id="2-2-10-类成员的排序"><a href="#2-2-10-类成员的排序" class="headerlink" title="2.2.10 类成员的排序"></a>2.2.10 类成员的排序</h3><p>这不是唯的答案，但是使用一个 <strong>逻辑性</strong> 和 <strong>一致性</strong> 的排序将改善你代码的可读性和可学性。推荐使用一下排序</p><ol><li>Constants(常量)</li><li>Fields(成员)</li><li>Constructors(构造)</li><li>Override methods and callbacks (public or private)(重写方法和回调)</li><li>Public methods (公共方法)</li><li>Private methods (私有方法)</li><li>Inner classes or interfaces (内部类和接口)</li></ol><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String mTitle;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextViewTitle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnInnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的类继承一个 <strong>Android组件</strong> 例如一个Activity 或Fragment，一个好的做法是 <strong>匹配组件的生命周期</strong> 排序重写方法。比如你继承Activity实现了<code>onCreate()</code>, <code>onDestroy()</code>, <code>onPause()</code> 和 <code>onResume()</code>, 那么正确的做法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Order matches Activity lifecycle</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-11-方法中参数的排序"><a href="#2-2-11-方法中参数的排序" class="headerlink" title="2.2.11 方法中参数的排序"></a>2.2.11 方法中参数的排序</h3><p>当你编写Android程序时，一个常见定义方法是写一个 <code>Context</code> 参数，如果你正在写一个这样的方法，必须将 <code>Context</code> 放在第一个参数。</p><p>相反 <strong>callback</strong> 接口应该永远放在最后一个参数。</p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context always goes first</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">loadUser</span><span class="params">(Context context, <span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callbacks always go last</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUserAsync</span><span class="params">(Context context, <span class="keyword">int</span> userId, UserCallback callback)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-13-字符常量、命名、取值"><a href="#2-2-13-字符常量、命名、取值" class="headerlink" title="2.2.13 字符常量、命名、取值"></a>2.2.13 字符常量、命名、取值</h3><p>在Andoid SDK中有许多使用了类似于健值对(key-value pair)的元素，像 <code>SharedPreferences</code>, <code>Bundle</code>, 和 <code>Intent</code>，这样及时一个很小的app也要定义许多字符常量。</p><p>当使用这些组件，你 <strong>必须</strong> 定义很多 <code>static final</code> 的 key，你应该使用下面这些前缀表示他们：</p><table><thead><tr><th>Element</th><th>Field Name Prefix</th></tr></thead><tbody><tr><td>SharedPreferences</td><td><code>PREF_</code></td></tr><tr><td>Bundle</td><td><code>BUNDLE_</code></td></tr><tr><td>Fragment Arguments</td><td><code>ARGUMENT_</code></td></tr><tr><td>Intent Extra</td><td><code>EXTRA_</code></td></tr><tr><td>Intent Action</td><td><code>ACTION_</code></td></tr></tbody></table><p>注意Fragment 的参数-<code>Fragment.getArguments()</code>-其实也是一个Bundle。然而，更准确的使用Bundle，我们应该定义不同的前缀区分它们，像上面那样。</p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note the value of the field is the same as the name to avoid duplication issues</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PREF_EMAIL = <span class="string">"PREF_EMAIL"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BUNDLE_AGE = <span class="string">"BUNDLE_AGE"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ARGUMENT_USER_ID = <span class="string">"ARGUMENT_USER_ID"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Intent-related items use full package name as value</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_SURNAME = <span class="string">"com.myapp.extras.EXTRA_SURNAME"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ACTION_OPEN_USER = <span class="string">"com.myapp.action.ACTION_OPEN_USER"</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-14-Fragments-Activities-中的参数"><a href="#2-2-14-Fragments-Activities-中的参数" class="headerlink" title="2.2.14 Fragments Activities 中的参数"></a>2.2.14 Fragments Activities 中的参数</h3><p>当数据被传递到 <code>Activity</code> 或 <code>Fragment</code> 通过一个 <code>Intent</code> 或 <code>Bundle</code>，传不同的值 <strong>必须</strong> 按照下面描述的规则执行。</p><p>当一个 <code>Activity</code> 或 <code>Fragment</code> 携带参数时，应该提供一个 <code>publi static</code> 方法有利于创建相关的 <code>Intent</code> 或 <code>Fragment</code>。</p><p>在Activity中创建Intent 携带参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">getStartIntent</span><span class="params">(Context context, User user)</span> </span>&#123;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, ThisActivity.class);</span><br><span class="line">intent.putParcelableExtra(EXTRA_USER, user);</span><br><span class="line"><span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Fragment应该命名为 <code>newInstance</code> 并且处理创建Framgnet携带的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserFragment <span class="title">newInstance</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">UserFragment fragment = <span class="keyword">new</span> UserFragment;</span><br><span class="line">Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">args.putParcelable(ARGUMENT_USER, user);</span><br><span class="line">fragment.setArguments(args)</span><br><span class="line"><span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意 1</strong>: 这些方法应该在类的顶部创建。</p><p><strong>注意 2</strong>: 如果我们提过上面描述的方法，额外的参数应该是 <code>private</code>，因为它不应该暴露给外部类。</p><h3 id="2-2-15-限制代码行的长度"><a href="#2-2-15-限制代码行的长度" class="headerlink" title="2.2.15 限制代码行的长度"></a>2.2.15 限制代码行的长度</h3><p>每行代码的长度应该不超过100个字符。</p><p>有关本规则的讨论有很多，最后的结论还是最多不超过100个字符。</p><h4 id="2-2-15-1-换行策略"><a href="#2-2-15-1-换行策略" class="headerlink" title="2.2.15.1 换行策略"></a>2.2.15.1 换行策略</h4><p>There isn’t an exact formula that explains how to line-wrap and quite often different solutions are valid. However there are a few rules that can be applied to common cases.</p><p><strong>Break at operators</strong></p><p>When the line is broken at an operator, the break comes <strong>before</strong> the operator. For example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne</span><br><span class="line">        + theFinalOne;</span><br></pre></td></tr></table></figure><p><strong>Assignment Operator Exception</strong></p><p>An exception to the <code>break at operators</code> rule is the assignment operator <code>=</code>, where the line break should happen <strong>after</strong> the operator.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> longName =</span><br><span class="line">        anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne;</span><br></pre></td></tr></table></figure><p><strong>Method chain case</strong></p><p>When multiple methods are chained in the same line - for example when using Builders - every call to a method should go in its own line, breaking the line before the <code>.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(context).load(<span class="string">"http://ribot.co.uk/images/sexyjoe.jpg"</span>).into(imageView);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(context)</span><br><span class="line">        .load(<span class="string">"http://ribot.co.uk/images/sexyjoe.jpg"</span>)</span><br><span class="line">        .into(imageView);</span><br></pre></td></tr></table></figure><p><strong>Long parameters case</strong></p><p>When a method has many parameters or its parameters are very long, we should break the line after every comma <code>,</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadPicture(context, <span class="string">"http://ribot.co.uk/images/sexyjoe.jpg"</span>, mImageViewProfilePicture, clickListener, <span class="string">"Title of the picture"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadPicture(context,</span><br><span class="line">        <span class="string">"http://ribot.co.uk/images/sexyjoe.jpg"</span>,</span><br><span class="line">        mImageViewProfilePicture,</span><br><span class="line">        clickListener,</span><br><span class="line">        <span class="string">"Title of the picture"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-16-RxJava-chains-styling"><a href="#2-2-16-RxJava-chains-styling" class="headerlink" title="2.2.16 RxJava chains styling"></a>2.2.16 RxJava chains styling</h3><p>Rx chains of operators require line-wrapping. Every operator must go in a new line and the line should be broken before the <code>.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;Location&gt; <span class="title">syncLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDatabaseHelper.getAllLocations()</span><br><span class="line">            .concatMap(<span class="keyword">new</span> Func1&lt;Location, Observable&lt;? extends Location&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> Observable&lt;? extends Location&gt; call(Location location) &#123;</span><br><span class="line">                     <span class="keyword">return</span> mRetrofitService.getLocation(location.id);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .retry(<span class="keyword">new</span> Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer numRetries, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> throwable <span class="keyword">instanceof</span> RetrofitError;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-XML-style-rules"><a href="#2-3-XML-style-rules" class="headerlink" title="2.3 XML style rules"></a>2.3 XML style rules</h2><h3 id="2-3-1-Use-self-closing-tags"><a href="#2-3-1-Use-self-closing-tags" class="headerlink" title="2.3.1 Use self closing tags"></a>2.3.1 Use self closing tags</h3><p>When an XML element doesn’t have any contents, you <strong>must</strong> use self closing tags.</p><p>This is good:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/text_view_profile"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>This is <strong>bad</strong> :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Don\'t do this! --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/text_view_profile"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-Resources-naming"><a href="#2-3-2-Resources-naming" class="headerlink" title="2.3.2 Resources naming"></a>2.3.2 Resources naming</h3><p>Resource IDs and names are written in <strong>lowercase_underscore</strong>.</p><h4 id="2-3-2-1-ID-naming"><a href="#2-3-2-1-ID-naming" class="headerlink" title="2.3.2.1 ID naming"></a>2.3.2.1 ID naming</h4><p>IDs should be prefixed with the name of the element in lowercase underscore. For example:</p><table><thead><tr><th>Element</th><th>Prefix</th></tr></thead><tbody><tr><td><code>TextView</code></td><td><code>text_</code></td></tr><tr><td><code>ImageView</code></td><td><code>image_</code></td></tr><tr><td><code>Button</code></td><td><code>button_</code></td></tr><tr><td><code>Menu</code></td><td><code>menu_</code></td></tr></tbody></table><p>Image view example:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/image_profile"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Menu example:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/menu_done"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"Done"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-2-Strings"><a href="#2-3-2-2-Strings" class="headerlink" title="2.3.2.2 Strings"></a>2.3.2.2 Strings</h4><p>String names start with a prefix that identifies the section they belong to. For example <code>registration_email_hint</code> or <code>registration_name_hint</code>. If a string <strong>doesn’t belong</strong> to any section, then you should follow the rules below:</p><table><thead><tr><th>Prefix</th><th>Description</th></tr></thead><tbody><tr><td><code>error_</code></td><td>An error message</td></tr><tr><td><code>msg_</code></td><td>A regular information message</td></tr><tr><td><code>title_</code></td><td>A title, i.e. a dialog title</td></tr><tr><td><code>action_</code></td><td>An action such as “Save” or “Create”</td></tr></tbody></table><h4 id="2-3-2-3-Styles-and-Themes"><a href="#2-3-2-3-Styles-and-Themes" class="headerlink" title="2.3.2.3 Styles and Themes"></a>2.3.2.3 Styles and Themes</h4><p>Unless the rest of resources, style names are written in <strong>UpperCamelCase</strong>.</p><h3 id="2-3-3-Attributes-ordering"><a href="#2-3-3-Attributes-ordering" class="headerlink" title="2.3.3 Attributes ordering"></a>2.3.3 Attributes ordering</h3><p>As a general rule you should try to group similar attributes together. A good way of ordering the most common attributes is:</p><ol><li>View Id</li><li>Style</li><li>Layout width and layout height</li><li>Other layout attributes, sorted alphabetically</li><li>Remaining attributes, sorted alphabetically</li></ol><h2 id="2-4-Tests-style-rules"><a href="#2-4-Tests-style-rules" class="headerlink" title="2.4 Tests style rules"></a>2.4 Tests style rules</h2><h3 id="2-4-1-Unit-tests"><a href="#2-4-1-Unit-tests" class="headerlink" title="2.4.1 Unit tests"></a>2.4.1 Unit tests</h3><p>Test classes should match the name of the class the tests are targeting, followed by <code>Test</code>. For example, if we create a test class that contains tests for the <code>DatabaseHelper</code>, we should name it <code>DatabaseHelperTest</code>.</p><p>Test methods are annotated with <code>@Test</code> and should generally start with the name of the method that is being tested, followed by a precondition and/or expected behaviour.</p><ul><li>Template: <code>@Test void methodNamePreconditionExpectedBehaviour()</code></li><li>Example: <code>@Test void signInWithEmptyEmailFails()</code></li></ul><p>Precondition and/or expected behaviour may not always be required if the test is clear enough without them.</p><p>Sometimes a class may contain a large amount of methods, that at the same time require several tests for each method. In this case, it’s recommendable to split up the test class into multiple ones. For example, if the <code>DataManager</code> contains a lot of methods we may want to divide it into <code>DataManagerSignInTest</code>, <code>DataManagerLoadUsersTest</code>, etc. Generally you will be able to see what tests belong together because they have common <a href="https://en.wikipedia.org/wiki/Test_fixture" target="_blank" rel="noopener">test fixtures</a>.</p><h3 id="2-4-2-Espresso-tests"><a href="#2-4-2-Espresso-tests" class="headerlink" title="2.4.2 Espresso tests"></a>2.4.2 Espresso tests</h3><p>Every Espresso test class usually targets an Activity, therefore the name should match the name of the targeted Activity followed by <code>Test</code>, e.g. <code>SignInActivityTest</code></p><p>When using the Espresso API it is a common practice to place chained methods in new lines.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onView(withId(R.id.view))</span><br><span class="line">        .perform(scrollTo())</span><br><span class="line">        .check(matches(isDisplayed()))</span><br></pre></td></tr></table></figure><h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2015 Ribot Ltd.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-项目指南&quot;&gt;&lt;a href=&quot;#1-项目指南&quot; class=&quot;headerlink&quot; title=&quot;1.项目指南&quot;&gt;&lt;/a&gt;1.项目指南&lt;/h1&gt;&lt;h2 id=&quot;1-1项目结构&quot;&gt;&lt;a href=&quot;#1-1项目结构&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Android" scheme="http://dxyoo7.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>git分支的约束和管理</title>
    <link href="http://dxyoo7.github.io/2016/09/22/git-branch-manage/"/>
    <id>http://dxyoo7.github.io/2016/09/22/git-branch-manage/</id>
    <published>2016-09-22T10:12:24.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>##一、分支说明</p><p>###master：</p><blockquote><ul><li>主分支，用作生产分支，里面的代码是准备部署到生产环境的。master 永远处于稳定状态，这个分支代码可以随时用来部署。     </li><li>master 不提交代码，只合并代码。</li><li>合并代码到 master 的操作，由项目对应的集成管理员专人负责。</li><li>各分支要定期将 master 代码合并进来，避免后续分支合并到 master 时容易产生冲突，以减轻集成管理员的合并负担。</li><li>发版之后，要打 tag 。</li></ul></blockquote><p>###develop：</p><blockquote><ul><li>从哪个分支分离开来：master</li><li>可以合并到哪个分支上：release</li></ul></blockquote><p>Develop（开发）分支，包含了项目最新的功能和代码，所有开发都在 develop 上进行。一般情况下小的修改直接在这个分支上提交代码。</p><p>###release：</p><blockquote><ul><li>从哪个分支分离开来：develop</li><li>必须要合并到哪个分支上：develop 与 master</li><li>分支的命名规范：release-*</li></ul></blockquote><p>Release （发行）分支，是为发行正式的生产版本做准备。当开发的差不多了，准备发行就可以创建一个发行分支，在这个分支上可以做一些小的 bug 修复，准备发行的元数据，比如版本号，发行日期之类的。这时候，develop 分支可以继续接收新的提交，为下一个发行做准备。</p><p>###feature：</p><blockquote><ul><li>从哪个分支分离开来：develop</li><li>必须要合并到哪个分支上：develop</li><li>分支的命名规范：除了 master，develop，release-，或者 hotfix- 以外的名字都可以</li></ul></blockquote><p>Feature（功能） 分支，有时候也叫 Topic 分支。在这种分支上去开发新的功能。当开发功能的时候，这个功能属于哪个目标发行还不知道。功能如果一直在开发，对应的这个功能分支就可以一直存在，不过到最后还是要合并到 develop 分支上，或者如果不想要开发的这个功能了，可以直接扔掉它。<br>Feature 分支一般只在开发者的 repo 里，而不是在 origin 上。</p><p>###hotfix：</p><blockquote><ul><li>从哪个分支分离开来：master</li><li>必须要合并到哪个分支上：develop 与 master</li><li>分支的命名规范：hotfix-*</li></ul></blockquote><p>当在生产版本上遇到 bug，你需要立即修复的时候，可以创建一个 Hotfix 分支，这个分支可以基于生产环境使用的对应的在 master 分支上的 tag 来创建。</p><p>###bugfix：</p><blockquote><ul><li>从哪个分支分离开来：master</li><li>必须要合并到哪个分支上：develop 与 master</li><li>分支的命名规范：hotfix-*</li></ul></blockquote><p>等同于hotfix，只是紧急性没有hotfix那么急迫。</p><p>如下图所示：</p><p><img src="http://nvie.com/img/git-model@2x.png" alt="git branch pic"></p><p>##二、分支开发<br>新版本开始：每个人从最新develop上checkout一个本地分支做开发；<br>本阶段：禁止直接在develop上开发； 如预期需要协助，可以几个人协同一个远端分支开发；一般会在远端创建version-develop分支</p><blockquote><ul><li>开发周期：一个版本的迭代周期，我们分成3个里程碑(v1, v2, v3);</li><li>v1版本：开发完成，会merge各自分支到develop；此时develop才进入下一个开发周期； 同时发布v1包给测试； v1的Bug，大家可以选择在develop上直接修改，或者继续在各自的本地分支上修改；</li><li>v2、v3版本：建议还是在各自的本地分支上继续开发； 完成feature后，同样merge回develop；</li></ul></blockquote><p>##三、分支操作参考</p><p>###master：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 合并release分支</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master --rebase</span><br><span class="line">git merge  --no-ff  release</span><br><span class="line">git tag V1.0</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 或者合并hotfix分支</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master --rebase</span><br><span class="line">git merge  --no-ff  release</span><br><span class="line">git tag V1.1</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>###develop：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 创建develop分支(第一次)</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master --rebase</span><br><span class="line">git checkout -b develop</span><br><span class="line">git push origin develop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 合并一般的feature分支（推送到远程的feature分支）</span><br><span class="line">git checkout develop</span><br><span class="line">git pull origin develop --rebase</span><br><span class="line">git merge  --no-ff  feature</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 合并较小的feature分支（不推送到远程的feature分支）</span><br><span class="line"># 1)获取最新develpo分支内容</span><br><span class="line">git checkout develop</span><br><span class="line">git pull origin develop --rebase</span><br><span class="line"># 2）回合develop</span><br><span class="line">git checkout feature</span><br><span class="line">git rebase develop</span><br><span class="line"># 3）merge feature</span><br><span class="line">git merge  --no-ff  feature</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></p><p>###release：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 从develop切出realse分支</span><br><span class="line">git checkout -b release</span><br><span class="line"> </span><br><span class="line"># 合并develop分支</span><br><span class="line">git pull origin release --rebase</span><br><span class="line">git merge  --no-ff  develop</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></p><p>###feature：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 从develop切出feature分支</span><br><span class="line">1) #拉取最新develop分支代码</span><br><span class="line">git checkout develop</span><br><span class="line">git pull origin develop  --rebase</span><br><span class="line">2）#切出新的feature分支</span><br><span class="line">git checkout -b feature</span><br><span class="line">3) #合并到develop(merge)</span><br><span class="line">git checkout develop</span><br><span class="line">git pull origin develop  --rebase</span><br><span class="line">git merge --no-ff feature</span><br><span class="line">git push origin develop</span><br><span class="line"> </span><br><span class="line">3) #合并到develop(rebase)</span><br><span class="line">git checkout develop</span><br><span class="line">git pull origin develop  --rebase</span><br><span class="line">git checkout feature</span><br><span class="line">git rebase develop</span><br><span class="line"># 如果有冲突，修改好后，执行以下（千万不要执行git commit XX）</span><br><span class="line">|| git add .</span><br><span class="line">|| git rebase --continue</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff feature</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></p><p>###hotfix：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 从master切出hotfix分支</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master --rebase</span><br><span class="line">git checkout -b hotfix</span><br><span class="line"> </span><br><span class="line"># master合并分支hotfix</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master --rebase</span><br><span class="line">git merge  --no-ff  hotfix</span><br><span class="line">git tag V1.1</span><br><span class="line">git push origin master</span><br><span class="line"> </span><br><span class="line"># develop合并分支hotfix</span><br><span class="line">git checkout develop</span><br><span class="line">git pull origin develop --rebase</span><br><span class="line">git merge  --no-ff  hotfix</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></p><p>###bugfix：</p><p>同hotfix，但不一定是从master分支切出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##一、分支说明&lt;/p&gt;
&lt;p&gt;###master：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主分支，用作生产分支，里面的代码是准备部署到生产环境的。master 永远处于稳定状态，这个分支代码可以随时用来部署。     &lt;/li&gt;
&lt;li&gt;master 不提交
      
    
    </summary>
    
    
      <category term="git" scheme="http://dxyoo7.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo，如果换了电脑怎么更新博客</title>
    <link href="http://dxyoo7.github.io/2016/09/22/how-install-in-other-pc/"/>
    <id>http://dxyoo7.github.io/2016/09/22/how-install-in-other-pc/</id>
    <published>2016-09-22T03:37:54.000Z</published>
    <updated>2017-11-27T06:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>#使用hexo，如果换了电脑怎么更新博客</p><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><ol><li>使用git clone git@github.com:{username}/{username}.github.io.git拷贝仓库；</li><li>切换源文件分支，（因为hexo使用master管理存放生成的page文件，我使用的hexo分支管理源文件）所以我要切换回hexo分支。</li><li>安装 npm install hexo -g (如果一安装跳过)，<br>npm install  ， npm install hexo-deployer-git， 确定 theme/* 主题目录存在，否则提示No layout index.html（记得，不需要hexo init这条指令）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#使用hexo，如果换了电脑怎么更新博客&lt;/p&gt;
&lt;p&gt;当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用git clone git@github.com:{username}/{username}.github.io.git拷贝
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://dxyoo7.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>代码回滚：Reset、Checkout、Revert的选择</title>
    <link href="http://dxyoo7.github.io/2016/08/15/how-choice-reset-checkout-revert/"/>
    <id>http://dxyoo7.github.io/2016/08/15/how-choice-reset-checkout-revert/</id>
    <published>2016-08-15T07:32:24.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转"><a href="#转" class="headerlink" title="转"></a><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.2-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A%EF%BC%9AReset%E3%80%81Checkout%E3%80%81Revert%E7%9A%84%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">转</a></h1><p>git reset、git checkout和git revert是你的Git工具箱中最有用的一些命令。它们都用来撤销代码仓库中的某些更改，而前两个命令不仅可以作用于提交，还可以作用于特定文件。</p><p>因为它们非常相似，所以我们经常会搞混，不知道什么场景下该用哪个命令。在这篇文章中，我们会比较git reset、git checkout和git revert最常见的用法。希望你在看完后能游刃有余地使用这些命令来管理你的仓库。</p><p><img src="https://camo.githubusercontent.com/eacc3cd372cf72b9902a1ff40b3db89df00e7539/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30312e737667" alt="reset"></p><p>Git仓库有三个主要组成——工作目录，缓存区和提交历史。这张图有助于理解每个命令到底产生了哪些影响。当你阅读的时候，牢记这张图。</p><h2 id="提交层面的操作"><a href="#提交层面的操作" class="headerlink" title="提交层面的操作"></a>提交层面的操作</h2><p>你传给git reset和git checkout的参数决定了它们的作用域。如果你没有包含文件路径，这些操作对所有提交生效。我们这一节要探讨的就是提交层面的操作。注意，git revert没有文件层面的操作。</p><h2 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h2><p>在提交层面上，reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交。比如，下面这两条命令让hotfix分支向后回退了两个提交。</p><p>git checkout hotfix<br>git reset HEAD~2<br>hotfix分支末端的两个提交现在变成了悬挂提交。也就是说，下次Git执行垃圾回收的时候，这两个提交会被删除。换句话说，如果你想扔掉这两个提交，你可以这么做。reset操作如下图所示：</p><p><img src="https://camo.githubusercontent.com/3d55df040cb530482894661b35212b83ff4e5e14/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30322e737667" alt="reset"></p><p>如果你的更改还没有共享给别人，git reset是撤销这些更改的简单方法。当你开发一个功能的时候发现『糟糕，我做了什么？我应该重新来过！』时，reset就像是go-to命令一样。</p><p>除了在当前分支上操作，你还可以通过传入这些标记来修改你的缓存区或工作目录：</p><ul><li><blockquote><p>–soft – 缓存区和工作目录都不会被改变</p></blockquote></li><li><blockquote><p>–mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响</p></blockquote></li><li><blockquote><p>–hard – 缓存区和工作目录都同步到你指定的提交<br>把这些标记想成定义git reset操作的作用域就容易理解多了</p></blockquote></li></ul><p><img src="https://camo.githubusercontent.com/6f605243c7eedce24cd32e53348d7f5b2db20bff/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30332e737667" alt="reset"></p><p>这些标记往往和HEAD作为参数一起使用。比如，git reset –mixed HEAD 将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中。另一方面，如果你想完全舍弃你没有提交的改动，你可以使用git reset –hard HEAD。这是git reset最常用的两种用法。</p><p>当你传入HEAD以外的其他提交的时候要格外小心，因为reset操作会重写当前分支的历史。正如Rebase黄金法则所说的，在公共分支上这样做可能会引起严重的后果。</p><h2 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h2><p>你应该已经非常熟悉提交层面的git checkout。当传入分支名时，可以切换到那个分支。</p><p>git checkout hotfix<br>上面这个命令做的不过是将HEAD移到一个新的分支，然后更新工作目录。因为这可能会覆盖本地的修改，Git强制你提交或者缓存工作目录中的所有更改，不然在checkout的时候这些更改都会丢失。和git reset不一样的是，git checkout没有移动这些分支。</p><p><img src="https://camo.githubusercontent.com/5d7183ad484d57e357ae45ea400ae565a533fe9a/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30342e737667" alt="reset"></p><p>除了分支之外，你还可以传入提交的引用来checkout到任意的提交。这和checkout到另一个分支是完全一样的：把HEAD移动到特定的提交。比如，下面这个命令会checkout到当前提交的祖父提交。</p><p>git checkout HEAD~2</p><p><img src="https://camo.githubusercontent.com/b6b326af6c5f485ea326120dd2f1f78e741d1748/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30352e737667" alt="reset"></p><p>这对于快速查看项目旧版本来说非常有用。但如果你当前的HEAD没有任何分支引用，那么这会造成HEAD分离。这是非常危险的，如果你接着添加新的提交，然后切换到别的分支之后就没办法回到之前添加的这些提交。因此，在为分离的HEAD添加新的提交的时候你应该创建一个新的分支。</p><h2 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h2><p>Revert撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p><p>git checkout hotfix<br>git revert HEAD~2<br>如下图所示：</p><p><img src="https://camo.githubusercontent.com/ca3c454935277b49e1c75e04644d979e796c50e8/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30362e737667" alt="reset"></p><p>相比git reset，它不会改变现在的提交历史。因此，git revert可以用在公共分支上，git reset应该用在私有分支上。</p><p>你也可以把git revert当作撤销已经提交的更改，而git reset HEAD用来撤销没有提交的更改。</p><p>就像git checkout 一样，git revert 也有可能会重写文件。所以，Git会在你执行revert之前要求你提交或者缓存你工作目录中的更改。</p><h2 id="文件层面的操作"><a href="#文件层面的操作" class="headerlink" title="文件层面的操作"></a>文件层面的操作</h2><p>git reset和git checkout 命令也接受文件路径作为参数。这时它的行为就大为不同了。它不会作用于整份提交，参数将它限制于特定文件。</p><h2 id="Reset-1"><a href="#Reset-1" class="headerlink" title="Reset"></a>Reset</h2><p>当检测到文件路径时，git reset 将缓存区同步到你指定的那个提交。比如，下面这个命令会将倒数第二个提交中的foo.py加入到缓存区中，供下一个提交使用。</p><p>git reset HEAD~2 foo.py<br>和提交层面的git reset一样，通常我们使用HEAD而不是某个特定的提交。运行git reset HEAD foo.py 会将当前的foo.py从缓存区中移除出去，而不会影响工作目录中对foo.py的更改。</p><p><img src="https://camo.githubusercontent.com/9919767b710f165cb3ee6b18cf32356a220e814f/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30372e737667" alt="reset"></p><p>–soft、–mixed和–hard对文件层面的git reset毫无作用，因为缓存区中的文件一定会变化，而工作目录中的文件一定不变。</p><h2 id="Checkout-1"><a href="#Checkout-1" class="headerlink" title="Checkout"></a>Checkout</h2><p>Checkout一个文件和带文件路径git reset 非常像，除了它更改的是工作目录而不是缓存区。不像提交层面的checkout命令，它不会移动HEAD引用，也就是你不会切换到别的分支上去。</p><p><img src="https://camo.githubusercontent.com/cf90b3529e12e1ccb439d1b45513e187fc90291d/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f616476616e6365642f726573657474696e672d636865636b696e672d6f75742d616e642d726576657274696e672f30382e737667" alt="hell"></p><p>比如，下面这个命令将工作目录中的foo.py同步到了倒数第二个提交中的foo.py。</p><p>git checkout HEAD~2 foo.py<br>和提交层面相同的是，它可以用来检查项目的旧版本，但作用域被限制到了特定文件。</p><p>如果你缓存并且提交了checkout的文件，它具备将某个文件回撤到之前版本的效果。注意它撤销了这个文件后面所有的更改，而git revert 命令只撤销某个特定提交的更改。</p><p>和git reset 一样，这个命令通常和HEAD一起使用。比如git checkout HEAD foo.py等同于舍弃foo.py没有缓存的更改。这个行为和git reset HEAD –hard很像，但只影响特定文件。</p><p>总结<br>你现在已经掌握了Git仓库中撤销更改的所有工具。git reset、git checkout、和 git revert命令比较容易混淆，但当你想起它们对工作目录、缓存区和提交历史的不同影响，就会容易判断现在应该用哪个命令。</p><p>下面这个表格总结了这些命令最常用的使用场景。记得经常对照这个表格，因为你使用Git时一定会经常用到。</p><table><thead><tr><th>命令</th><th style="text-align:right">作用域</th><th style="text-align:center">常用情景</th></tr></thead><tbody><tr><td>git reset</td><td style="text-align:right">提交层面</td><td style="text-align:center">在私有分支上舍弃一些没有提交的更改</td></tr><tr><td>git reset</td><td style="text-align:right">文件层面</td><td style="text-align:center">将文件从缓存区中移除</td></tr><tr><td>git checkout</td><td style="text-align:right">提交层面</td><td style="text-align:center">切换分支或查看旧版本</td></tr><tr><td>git checkout</td><td style="text-align:right">文件层面</td><td style="text-align:center">舍弃工作目录中的更改</td></tr><tr><td>git revert</td><td style="text-align:right">提交层面</td><td style="text-align:center">在公共分支上回滚更改</td></tr><tr><td>git revert</td><td style="text-align:right">文件层面</td><td style="text-align:center">然而并没有</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转&quot;&gt;&lt;a href=&quot;#转&quot; class=&quot;headerlink&quot; title=&quot;转&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/wiki/5.2-%E4%BB%A3%E7%A0%81%E5%
      
    
    </summary>
    
    
      <category term="git" scheme="http://dxyoo7.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android 主题层级</title>
    <link href="http://dxyoo7.github.io/2016/07/08/Android-Themes-An-in-depth-guide/"/>
    <id>http://dxyoo7.github.io/2016/07/08/Android-Themes-An-in-depth-guide/</id>
    <published>2016-07-08T08:23:49.000Z</published>
    <updated>2017-11-27T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【译】Android-主题层级"><a href="#【译】Android-主题层级" class="headerlink" title="【译】Android 主题层级"></a>【译】Android 主题层级</h1><p><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown</a></p><p>Theme.AppCompat, Theme.Base.AppCompat, Base.V7.Theme.AppCompat, Base.v11.Theme.AppCompat, Base.v21.Theme.AppCompat, ThemeOverlay, Platform.AppCompat, DeviceDefault, Material, Holo, Classic…</p><p>假如你使用Android themes 和一些 support 库时，有时你可能会问自己：</p><blockquote><ul><li>这些 Base.V{?}, Theme.Base.AppCompat Platform.AppCompat 是什么呀?</li><li>这些主题是怎么组织的?</li><li>我该使用哪一个?</li></ul></blockquote><p>在这篇文章中我准备回答这些问题并且尝试理清那些没人知道如何组合在一起。</p><h2 id="AppCompat-v7"><a href="#AppCompat-v7" class="headerlink" title="AppCompat v7"></a>AppCompat v7</h2><p>鉴于不同的安卓平台定义了不同的主题、样式和属性，最初安卓主题的层级非常繁杂，而且很不直观。直到 v7 支持库带来了全新的主题<strong>架构</strong>，使得所有安卓平台自 API v7 起能够获得一致的材质外观 (Matertial apperance)。<em>Base.V…</em> 和 <em>Platform.AppCompat</em> 正是在这个时候被加入了进来。 </p><blockquote><p>在Github上有一份 README 文件，该文件解释了主题的层级关系，我建议看一下。</p></blockquote><p><a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/THEMES.txt" target="_blank" rel="noopener">https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/THEMES.txt</a></p><p>在 <em>AppCompat</em> 主题是四个层次的结构，每个层次继承自更低一层：</p><p><strong>Level1 → Level2 → Level3 → Level4</strong></p><p>除此之外，每个版本的安卓 API 都有一个对应的 <em>values-v{api}</em> 文件夹存放各自需要定义或覆写的样式和属性：</p><p><strong>values, values-v11, values-v14, values-v21, values-v22, values-v23</strong></p><h2 id="Level-4-最底层"><a href="#Level-4-最底层" class="headerlink" title="Level 4(最底层)"></a>Level 4(最底层)</h2><p>最底层包含了 <em>Platform.AppCompat</em> 主题。该主题总是继承自当前版本中的默认主题，例如：</p><p><strong>values</strong></p><p><em>Platform.AppCompat -&gt; android:Theme</em></p><p><strong>values-v11</strong></p><p><em>Platform.AppCompat -&gt; android:Theme.Holo</em></p><p><strong>values-v21</strong></p><p><em>Platform.AppCompat -&gt; android:Theme.Material</em></p><h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p>大部分工作都在 <strong>Base.V7.Theme.AppCompat, Base.V11.Theme.AppCompat, Base.V21.Theme.AppCompat</strong>, 等的定义中完成，这层主题继承自 Platform.AppCompat</p><p><strong>values</strong></p><p><em>Base.V7.Theme.AppCompat → Platform.AppCompat → android:Theme</em></p><p><strong>values-v11</strong></p><p><em>Base.V11.Theme.AppCompat → Platform.AppCompat → android:Theme.Holo</em></p><p><strong>values-v21</strong></p><p><em>Base.V21.ThemeAppCompat → Base.V7.ThemeAppCompat → Platform.AppCompat → android:Theme.Material</em></p><blockquote><p>* 还包括 Base.V7.Theme.AppCompat.Light, Base.V7.Theme.AppCompat.Dialog, 等变体。</p></blockquote><p>绝大部分属性和工作都已在 Base.V{api}.Theme.AppCompat 主题中定义及完成。ActionBar, DropwDown, ActionMode, Panel, List, Spinner, Toolbar 等控件的所有主题都定义在这里，你可以通过此链接查看详细内容。<br><a href="https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/res/values/themes_base.xml" target="_blank" rel="noopener">https://github.com/android/platform_frameworks_support/blob/master/v7/appcompat/res/values/themes_base.xml</a></p><h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p>根据安卓的官方解释，我们在这一层拿到的主题只是第三层主题的别名：</p><blockquote><p>There are the themes which are pointers to the correct third level theme.They can also be used to set attributes for that specific platform (and platforms up until the next declaration).<br>这些主题指向第三层中相应的主题。它们也可以用来配置那些特定平台的属性。</p></blockquote><p>这层主题指向第三层主题，他们可以被设置到指定的平台的 attributes 标签中(and platforms up until the next declaration)</p><p><strong>values</strong></p><p>Base.Theme.AppCompat* → Base.V7.Theme.AppCompat</p><p><strong>values-v21</strong> </p><p>Base.Theme.AppCompat → Base.V21.Theme.AppCompat</p><blockquote><p>和类似于 Base.Theme.AppCompat.Light, Base.Theme.AppCompat.Dialog, 等…</p></blockquote><h2 id="Level-1-顶层"><a href="#Level-1-顶层" class="headerlink" title="Level 1(顶层)"></a>Level 1(顶层)</h2><p><em>Theme.AppCompat, Theme.AppCompat.Light, Theme.AppCompat.NoActionBar</em> <strong>等主题在这里被定义。开发者应该使用这些主题，而非那些更底层的。</strong></p><p><strong>values</strong></p><p>Theme.AppCompat → Base.Theme.AppCompat</p><p>这些主题只在 values 文件夹中被定义，并根据安卓应用运行的 API 环境，继承自下层中定义的相应主题。例如：</p><p><strong>运行在 v7 (Android2.2)</strong></p><p><em>Theme.AppCompat → Base.Theme.AppCompat → Base.V7.Theme.AppCompat → Platform.AppCompat → android:Theme</em></p><p><strong>运行在 v11 (Android3.0)</strong></p><p><em>Theme.AppCompat → Base.Theme.AppCompat → Base.V7.Theme.AppCompat → Platform.AppCompat → Platform.V11.AppCompat → android:Theme.Holo</em></p><p><strong>运行在 v21 (Android 5.0)</strong></p><p><em>Theme.AppCompat → Base.Theme.AppCompat → Base.V21.Theme.AppCompat → Base.V7.Theme.AppCompat → Platform.AppCompat → android:Theme.Material</em></p><p>这就是你如何能够在所有Android api中得到一个统一 Material 风格，正如你所见的通过主题层级寻找是复杂的。</p><h2 id="Theme-Diagram-simplified"><a href="#Theme-Diagram-simplified" class="headerlink" title="Theme Diagram(simplified)"></a>Theme Diagram(simplified)</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*iCallLnKKdoj_82nvNxfLw.png" alt="hello-world"></p><p>ThemeOverlays<br>在所有可用的主题中，我们可以发现一个名字带有 ThemeOverlay 的系列：</p><p>ThemeOverlay<br>ThemeOverlay.Light<br>ThemeOverlay.ActionBar.Light<br>ThemeOverlay.ActionBar.Dark</p><p>这些主题又是做什么的呢？答案是 仅用于为特定的用途定义必要的属性。 例如 ThemeOverlay 主题只定义了 textColor，textAppearance，窗口的颜色属性和一些类似 colorControlButton 的属性；通常用作于 Toolbar 主题的 ThemeOverlay.ActionBar.Light，仅将 colorControlButton 的值定义为 ?attr:textColorSecondary。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【译】Android-主题层级&quot;&gt;&lt;a href=&quot;#【译】Android-主题层级&quot; class=&quot;headerlink&quot; title=&quot;【译】Android 主题层级&quot;&gt;&lt;/a&gt;【译】Android 主题层级&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://w
      
    
    </summary>
    
    
  </entry>
  
</feed>
