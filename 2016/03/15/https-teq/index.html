<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> https 技术浅析 · Martin's Blog</title><meta name="description" content="https 技术浅析 - Martin D"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dxyoo7.github.io/atom.xml" title="Martin's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/dxyoo7" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">https 技术浅析</h1><div class="post-info">2016年3月15日</div><div class="post-content"><p><img src="http://bugly.qq.com/bbs/data/attachment/forum/201512/25/095101uw2tf099v7hpw2tp.jpg" alt="https logo"></p>
<h2 id="HTTPS-基础"><a href="#HTTPS-基础" class="headerlink" title="HTTPS 基础"></a>HTTPS 基础</h2><p>HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议 它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版,是使用 TLS/SSL 加密的 HTTP 协议。</p>
<p>HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功能，可以避免此类问题。</p>
<p>TLS/SSL 全称安全传输层协议 Transport Layer Security, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。</p>
<p><img src="http://i.imgur.com/0Mynsnm.gif" alt="https layer"></p>
<h2 id="TLS-SSL-原理"><a href="#TLS-SSL-原理" class="headerlink" title="TLS/SSL 原理"></a>TLS/SSL 原理</h2><p>HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，本节分析安全协议的实现原理。<br>TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p>
<p><img src="http://i.imgur.com/2snzFs9.gif" alt="tls/ssl"></p>
<p>1、<strong>散列函数</strong> Hash，常见的有 <code>MD5</code>、<code>SHA1</code>、<code>SHA256</code>，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性；</p>
<p>2、<strong>对称加密</strong>，常见的有 <code>AES-CBC</code>、<code>DES</code>、<code>3DES</code>、<code>AES-GCM</code>等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1；</p>
<p>3、<strong>非对称加密</strong>，即常见的 <code>RSA</code> 算法，还包括 <code>ECC</code>、<code>DH</code> 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。</p>
<p>在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密；对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制；非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。</p>
<p>结合三类算法的特点，TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p>
<h2 id="PKI-体系"><a href="#PKI-体系" class="headerlink" title="PKI 体系"></a>PKI 体系</h2><h3 id="3-1-RSA-身份验证的隐患"><a href="#3-1-RSA-身份验证的隐患" class="headerlink" title="3.1 RSA 身份验证的隐患"></a>3.1 RSA 身份验证的隐患</h3><p>身份验证和密钥协商是 TLS 的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但 RSA 算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患:<br>客户端 C 和服务器 S 进行通信，中间节点 M 截获了二者的通信；<br>节点 M 自己计算产生一对公钥 pub_M 和私钥 pri_M;<br>C 向 S 请求公钥时，M 把自己的公钥 pub_M 发给了 C;<br>C 使用公钥 pub_M 加密的数据能够被 M 解密，因为 M 掌握对应的私钥 pri_M，而 C 无法根据公钥信息判断服务器的身份，从而 C 和 M 之间建立了”可信”加密连接;<br>中间节点 M 和服务器S之间再建立合法的连接，因此 C 和 S 之间通信被M完全掌握，M 可以进行信息的窃听、篡改等操作。<br>另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。<br>因此该方案下至少存在两类问题：中间人攻击和信息抵赖。<br><img src="http://i.imgur.com/69EUIf1.png" alt="PKI logo"></p>
<h3 id="3-2-身份验证-CA-和证书"><a href="#3-2-身份验证-CA-和证书" class="headerlink" title="3.2 身份验证-CA 和证书"></a>3.2 身份验证-CA 和证书</h3><p>解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构 CA。CA 负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务，即 PKI 体系。</p>
<p>基本的原理为，CA 负责审核信息，然后对关键信息利用私钥进行”签名”，公开对应的公钥，客户端可以利用公钥验证签名。CA 也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA 使用具体的流程如下：<br><img src="http://i.imgur.com/cMUd921.png" alt="CA logo"></p>
<p>a.服务方 S 向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证；<br>b.CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；<br>c.如信息审核通过，CA 会向申请者签发认证文件-证书。<br>证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；<br>签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名；<br>d.客户端 C 向服务器 S 发出请求时，S 返回证书文件；<br>e.客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；<br>f.客户端然后验证证书相关的域名信息、有效时间等信息；<br>g.客户端会内置信任 CA 的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA 的证书，证书也会被判定非法。</p>
<p>在这个过程注意几点：<br>a.申请证书不需要提供私钥，确保私钥永远只能服务器掌握；<br>b.证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名；<br>c.内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书；<br>d.证书=公钥+申请者与颁发者信息+签名；</p>
<h2 id="4-TLS-SSL-握手过程"><a href="#4-TLS-SSL-握手过程" class="headerlink" title="4.TLS/SSL 握手过程"></a>4.TLS/SSL 握手过程</h2><h3 id="4-1握手与密钥协商过程"><a href="#4-1握手与密钥协商过程" class="headerlink" title="4.1握手与密钥协商过程"></a>4.1握手与密钥协商过程</h3><p>基于 RSA 握手和密钥交换的客户端验证服务器为示例详解握手过程。<br><img src="http://i.imgur.com/b36L4V2.png" alt="tls/ssl handshock"></p>
<h4 id="1-client-hello"><a href="#1-client-hello" class="headerlink" title="1.client_hello"></a>1.client_hello</h4><p>客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息，相关信息如下：<br>支持的最高TSL协议版本version，从低到高依次 SSLv2 SSLv3 TLSv1  TLSv1.1 TLSv1.2，当前基本不再使用低于 TLSv1 的版本；<br>客户端支持的加密套件 cipher suites 列表， 每个加密套件对应前面 TLS 原理中的四个功能的组合：认证算法 Au (身份验证)、密钥交换算法 KeyExchange(密钥协商)、对称加密算法 Enc (信息加密)和信息摘要 Mac(完整性校验);<br>支持的压缩算法 compression methods 列表，用于后续的信息压缩传输；<br>随机数 random_C，用于后续的密钥的生成；<br>扩展字段 extensions，支持协议与算法的相关参数以及其它辅助信息等，常见的 SNI 就属于扩展字段，后续单独讨论该字段作用。</p>
<h4 id="2-server-hello-server-certificate-sever-hello-done"><a href="#2-server-hello-server-certificate-sever-hello-done" class="headerlink" title="2.server_hello+server_certificate+sever_hello_done"></a>2.server_hello+server_certificate+sever_hello_done</h4><p>(a) server_hello, 服务端返回协商的信息结果，包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 等，其中随机数用于后续的密钥协商;<br>(b)server_certificates, 服务器端配置对应的证书链，用于身份验证与密钥交换；<br>(c) server_hello_done，通知客户端 server_hello 信息发送结束；</p>
<h4 id="3-证书校验"><a href="#3-证书校验" class="headerlink" title="3.证书校验"></a>3.证书校验</h4><p>客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作，合法性验证包括如下：<br>证书链的可信性 trusted certificate path，方法如前文所述；<br>证书是否吊销 revocation，有两类方式离线 CRL 与在线 OCSP，不同的客户端行为会不同；<br>有效期 expiry date，证书是否在有效时间范围；<br>域名 domain，核查证书域名是否与当前的访问域名匹配，匹配规则后续分析；</p>
<h4 id="4-client-key-exchange-change-cipher-spec-encrypted-handshake-message"><a href="#4-client-key-exchange-change-cipher-spec-encrypted-handshake-message" class="headerlink" title="4.client_key_exchange+change_cipher_spec+encrypted_handshake_message"></a>4.client_key_exchange+change_cipher_spec+encrypted_handshake_message</h4><p>(a) client_key_exchange，合法性验证通过之后，客户端计算产生随机数字 Pre-master，并用证书公钥加密，发送给服务器；<br>(b) 此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，计算得到协商密钥;<br>enc_key=Fuc(random_C, random_S, Pre-Master)<br>(c) change_cipher_spec，客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信;<br>(d) encrypted_handshake_message，结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证;</p>
<h4 id="5-change-cipher-spec-encrypted-handshake-message"><a href="#5-change-cipher-spec-encrypted-handshake-message" class="headerlink" title="5.change_cipher_spec+encrypted_handshake_message"></a>5.change_cipher_spec+encrypted_handshake_message</h4><p>(a) 服务器用私钥解密加密的 Pre-master 数据，基于之前交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥:enc_key=Fuc(random_C, random_S, Pre-Master)；<br>(b) 计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性；<br>(c) change_cipher_spec, 验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信；<br>(d) encrypted_handshake_message, 服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥 session secret 与算法加密并发送到客户端；</p>
<h4 id="6-握手结束"><a href="#6-握手结束" class="headerlink" title="6.握手结束"></a>6.握手结束</h4><p>客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成；</p>
<h4 id="7-加密通信"><a href="#7-加密通信" class="headerlink" title="7.加密通信"></a>7.加密通信</h4><p>开始使用协商密钥与算法进行加密通信。<br>注意：<br>(a) 服务器也可以要求验证客户端，即双向认证，可以在过程2要发送 client_certificate_request 信息，客户端在过程4中先发送 client_certificate与certificate_verify_message 信息，证书的验证方式基本相同，certificate_verify_message 是采用client的私钥加密的一段基于已经协商的通信信息得到数据，服务器可以采用对应的公钥解密并验证；<br>(b) 根据使用的密钥交换算法的不同，如 ECC 等，协商细节略有不同，总体相似；<br>(c) sever key exchange 的作用是 server certificate 没有携带足够的信息时，发送给客户端以计算 pre-master，如基于 DH 的证书，公钥不被证书中包含，需要单独发送；<br>(d) change cipher spec 实际可用于通知对端改版当前使用的加密通信方式，当前没有深入解析；<br>(e) alter message 用于指明在握手或通信过程中的状态改变或错误信息，一般告警信息触发条件是连接关闭，收到不合法的信息，信息解密失败，用户取消操作等，收到告警信息之后，通信会被断开或者由接收方决定是否断开连接。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/15/androidmanifest-how-to-merge/" class="prev">上一篇</a><a href="/2016/03/14/hexo-use-ssh-free-login/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://dxyoo7.github.io">Martin D</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>