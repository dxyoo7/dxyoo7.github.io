<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Architecture Components研究 · Martin's Blog</title><meta name="description" content="Android Architecture Components研究 - Martin D"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dxyoo7.github.io/atom.xml" title="Martin's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/dxyoo7" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Architecture Components研究</h1><div class="post-info">2018年4月11日</div><div class="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Google IO 2017发布Android Architecture Components，自己先研究了一下，蛮有意思的，特来记录一下。本文内容主要是参考官方文档以及自己的理解，如有错误之处，恳请指出。</p>
<p>Android Architecture Components<br>Android Architecture Components是Google发布的一套新的架构组件，使App的架构更加健壮，后面简称AAC。</p>
<p>AAC主要提供了Lifecycle，ViewModel，LiveData，Room等功能，下面依次说明：</p>
<p><strong>Lifecycle</strong><br>生命周期管理，把原先Android生命周期的中的代码抽取出来，如将原先需要在onStart()等生命周期中执行的代码分离到Activity或者Fragment之外。</p>
<p><strong>LiveData</strong><br>一个数据持有类，持有数据并且这个数据可以被观察被监听，和其他Observer不同的是，它是和Lifecycle是绑定的，在生命周期内使用有效，减少内存泄露和引用问题。</p>
<p><strong>ViewModel</strong><br>用于实现架构中的ViewModel，同时是与Lifecycle绑定的，使用者无需担心生命周期。可以在多个Fragment之间共享数据，比如旋转屏幕后Activity会重新create，这时候使用ViewModel还是之前的数据，不需要再次请求网络数据。</p>
<p><strong>Room</strong><br>谷歌推出的一个Sqlite ORM库，不过使用起来还不错，使用注解，极大简化数据库的操作，有点类似Retrofit的风格。</p>
<p>AAC的架构是这样的：<br><img src="https://raw.githubusercontent.com/LiushuiXiaoxia/AndroidArchitectureComponents/master/doc/final-architecture.png" alt="AAC"></p>
<ul>
<li>Activity/Fragment</li>
</ul>
<p>UI层，通常是Activity/Fragment等，监听ViewModel，当VIewModel数据更新时刷新UI，监听用户事件反馈到ViewModel，主流的数据驱动界面。</p>
<ul>
<li>ViewModel</li>
</ul>
<p>持有或保存数据，向Repository中获取数据，响应UI层的事件，执行响应的操作，响应数据变化并通知到UI层。</p>
<ul>
<li>Repository</li>
</ul>
<p>App的完全的数据模型，ViewModel交互的对象，提供简单的数据修改和获取的接口，配合好网络层数据的更新与本地持久化数据的更新，同步等</p>
<ul>
<li>Data Source</li>
</ul>
<p>包含本地的数据库等，网络api等，这些基本上和现有的一些MVVM，以及Clean架构的组合比较相似</p>
<p><strong>Gradle 集成</strong></p>
<p>根目录gradle文件中添加Google Maven Repository</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url &apos;https://maven.google.com&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块中添加对应的依赖</p>
<p>如使用Lifecycle,LiveData、ViewModel，添加如下依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;android.arch.lifecycle:runtime:1.0.0-alpha1&quot;</span><br><span class="line">compile &quot;android.arch.lifecycle:extensions:1.0.0-alpha1&quot;</span><br><span class="line">annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0-alpha1&quot;</span><br></pre></td></tr></table></figure>
<p>如使用Room功能，添加如下依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;android.arch.persistence.room:runtime:1.0.0-alpha1&quot;</span><br><span class="line">annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0-alpha1&quot;</span><br><span class="line"></span><br><span class="line">// For testing Room migrations, add:</span><br><span class="line">testCompile &quot;android.arch.persistence.room:testing:1.0.0-alpha1&quot;</span><br><span class="line"></span><br><span class="line">// For Room RxJava support, add:</span><br><span class="line">compile &quot;android.arch.persistence.room:rxjava2:1.0.0-alpha1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="LifeCycles"><a href="#LifeCycles" class="headerlink" title="LifeCycles"></a>LifeCycles</h3><p>Android开发中，经常需要管理生命周期。举个栗子，我们需要获取用户的地址位置，当这个Activity在显示的时候，我们开启定位功能，然后实时获取到定位信息，当页面被销毁的时候，需要关闭定位功能。</p>
<p>下面是简单的示例代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyLocationListener &#123;</span><br><span class="line">    public MyLocationListener(Context context, Callback callback) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void start() &#123;</span><br><span class="line">        // connect to system location service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void stop() &#123;</span><br><span class="line">        // disconnect from system location service</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = new MyLocationListener(this, (location) -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是一个简单的场景，我们来个复杂一点的场景。当定位功能需要满足一些条件下才开启，那么会变得复杂多了。可能在执行Activity的stop方法时，定位的start方法才刚刚开始执行，比如如下代码，这样生命周期管理就变得很麻烦了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity extends AppCompatActivity &#123;</span><br><span class="line">    private MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = new MyLocationListener(this, location -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            // what if this callback is invoked AFTER activity is stopped?</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AAC中提供了Lifecycle，用来帮助我们解决这样的问题。LifeCycle使用2个枚举类来解决生命周期管理问题。一个是事件，一个是状态。</p>
<p>事件：</p>
<p>生命周期事件由系统来分发，这些事件对于与Activity和Fragment的生命周期函数。</p>
<p>状态：</p>
<p>Lifecycle的状态，用于追踪中Lifecycle对象，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/LiushuiXiaoxia/AndroidArchitectureComponents/master/doc/lifecycle-states.png" alt=""></p>
<p>上面的定位功能代码，使用LifeCycle实现以后是这样的，实现一个LifecycleObserver接口，然后用注解标注状态，最后在LifecycleOwner中添加监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyObserver implements LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    public void onResume() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    public void onPause() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aLifecycleOwner.getLifecycle().addObserver(new MyObserver());</span><br></pre></td></tr></table></figure>
<p>上面代码中用到了<code>LifecycleOwner</code>是<code>LifecycleOwner</code>接口对象，<code>LifecycleOwner</code>是一个只有一个方法的接口<code>getLifecycle()</code>，需要由子类来实现。</p>
<p>在Lib中已经有实现好的子类，我们可以直接拿来使用。比如<code>LifecycleActivity</code>和<code>LifecycleFragment</code>，我们只需要继承此类就行了。</p>
<p>当然实际开发的时候我们会自己定义<code>BaseActivity</code>，Java是单继承模式，那么需要自己实现<code>LifecycleRegistryOwner</code>接口。</p>
<p>如下所示即可，代码很近简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BaseFragment extends Fragment implements LifecycleRegistryOwner &#123;</span><br><span class="line"></span><br><span class="line">    LifecycleRegistry lifecycleRegistry = new LifecycleRegistry(this);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LifecycleRegistry getLifecycle() &#123;</span><br><span class="line">        return lifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><code>LiveData</code> 是一个 <code>Data Holder</code> 类，可以持有数据，同时这个数据可以被监听的，当数据改变的时候，可以触发回调。但是又不像普通的Observable，LiveData绑定了App的组件，<code>LiveData</code>可以指定在<code>LifeCycle</code>的某个状态被触发。比如<code>LiveData</code>可以指定在<code>LifeCycle</code>的 <code>STARTED</code> 或 <code>RESUMED</code>状体被触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class LocationLiveData extends LiveData&lt;Location&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private LocationManager locationManager;</span><br><span class="line"></span><br><span class="line">    private SimpleLocationListener listener = new SimpleLocationListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onLocationChanged(Location location) &#123;</span><br><span class="line">            setValue(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public LocationLiveData(Context context) &#123;</span><br><span class="line">        locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onActive() &#123;</span><br><span class="line">        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onInactive() &#123;</span><br><span class="line">        locationManager.removeUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onActive()</code><br>这个方法在<code>LiveData</code>在被激活的状态下执行，我们可以开始执行一些操作。</p>
<p><code>onActive()</code><br>这个方法在<code>LiveData</code>在的失去活性状态下执行，我们可以结束执行一些操作。</p>
<p><code>setValue()</code><br>执行这个方法的时候，<code>LiveData</code>可以触发它的回调。</p>
<p><code>LocationLiveData</code>可以这样使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyFragment extends LifecycleFragment &#123;</span><br><span class="line"></span><br><span class="line">    public void onActivityCreated (Bundle savedInstanceState) &#123;</span><br><span class="line">        LiveData&lt;Location&gt; myLocationListener = ...;</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                myLocationListener.addObserver(this, location -&gt; &#123;</span><br><span class="line">                    // update UI</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，上面的<code>addObserver</code>方法，必须传<code>LifecycleOwner</code>对象，也就是说添加的对象必须是可以被<code>LifeCycle</code>管理的。</p>
<p>如果<code>LifeCycle</code>没有触发对对应的状态（<code>STARTED</code> or <code>RESUMED</code>），它的值被改变了，那么<code>Observe</code>就不会被执行，</p>
<p>如果<code>LifeCycle</code>被销毁了，那么<code>Observe</code>将自动被删除。</p>
<p>实际上<code>LiveData</code>就提供一种新的供数据共享方式。可以用它在多个<code>Activity</code>、<code>Fragment</code>等其他有生命周期管理的类中实现数据共享。</p>
<p>还是上面的定位例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class LocationLiveData extends LiveData&lt;Location&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static LocationLiveData sInstance;</span><br><span class="line"></span><br><span class="line">    private LocationManager locationManager;</span><br><span class="line"></span><br><span class="line">    @MainThread</span><br><span class="line">    public static LocationLiveData get(Context context) &#123;</span><br><span class="line">        if (sInstance == null) &#123;</span><br><span class="line">            sInstance = new LocationLiveData(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SimpleLocationListener listener = new SimpleLocationListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onLocationChanged(Location location) &#123;</span><br><span class="line">            setValue(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private LocationLiveData(Context context) &#123;</span><br><span class="line">        locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onActive() &#123;</span><br><span class="line">        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onInactive() &#123;</span><br><span class="line">        locationManager.removeUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Fragment中调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyFragment extends LifecycleFragment &#123;</span><br><span class="line"></span><br><span class="line">    public void onActivityCreated (Bundle savedInstanceState) &#123;</span><br><span class="line"></span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                LocationLiveData.get(getActivity()).observe(this, location -&gt; &#123;</span><br><span class="line">                   // update UI</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例，可以得到使用LiveData优点：</p>
<blockquote>
<ul>
<li><p>没有内存泄露的风险，全部绑定到对应的生命周期，当LifeCycle被销毁的时候，它们也自动被移除</p>
</li>
<li><p>降低Crash，当Activity被销毁的时候，LiveData的Observer自动被删除，然后UI就不会再接受到通知</p>
</li>
<li><p>实时数据，因为LiveData是持有真正的数据的，所以当生命周期又重新开始的时候，又可以重新拿到数据</p>
</li>
<li><p>正常配置改变，当Activity或者Fragment重新创建的时候，可以从LiveData中获取上一次有用的数据</p>
</li>
</ul>
</blockquote>
<p>不再需要手动的管理生命周期</p>
<p>Transformations<br>有时候需要对一个LiveData做Observer，但是这个LiveData是依赖另外一个LiveData，有点类似于RxJava中的操作符，我们可以这样做。</p>
<p>Transformations.map()<br>用于事件流的传递，用于触发下游数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class="line">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class="line">    user.name + &quot; &quot; + user.lastName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Transformations.switchMap()<br>这个和map类似，只不过这个是用来触发上游数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private LiveData&lt;User&gt; getUser(String id) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveData&lt;String&gt; userId = ...;</span><br><span class="line">LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );</span><br></pre></td></tr></table></figure></p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel是用来存储UI层的数据，以及管理对应的数据，当数据修改的时候，可以马上刷新UI。</p>
<p>Android系统提供控件，比如Activity和Fragment，这些控件都是具有生命周期方法，这些生命周期方法被系统调用。</p>
<p>当这些控件被销毁或者被重建的时候，如果数据保存在这些对象中，那么数据就会丢失。比如在一个界面，保存了一些用户信息，当界面重新创建的时候，就需要重新去获取数据。当然了也可以使用控件自动再带的方法，在onSaveInstanceState方法中保存数据，在onCreate中重新获得数据，但这仅仅在数据量比较小的情况下。如果数据量很大，这种方法就不能适用了。</p>
<p>另外一个问题就是，经常需要在Activity中加载数据，这些数据可能是异步的，因为获取数据需要花费很长的时间。那么Activity就需要管理这些数据调用，否则很有可能会产生内存泄露问题。最后需要做很多额外的操作，来保证程序的正常运行。</p>
<p>同时Activity不仅仅只是用来加载数据的，还要加载其他资源，做其他的操作，最后Activity类变大，就是我们常讲的上帝类。也有不少架构是把一些操作放到单独的类中，比如MVP就是这样，创建相同类似于生命周期的函数做代理，这样可以减少Activity的代码量，但是这样就会变得很复杂，同时也难以测试。</p>
<p>AAC中提供ViewModel可以很方便的用来管理数据。我们可以利用它来管理UI组件与数据的绑定关系。ViewModel提供自动绑定的形式，当数据源有更新的时候，可以自动立即的更新UI。</p>
<p>下面是一个简单的代码示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyViewModel extends ViewModel &#123;</span><br><span class="line"></span><br><span class="line">    private MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        if (users == null) &#123;</span><br><span class="line">            users = new MutableLiveData&lt;List&lt;Users&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadUsers() &#123;</span><br><span class="line">        // do async operation to fetch users</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(this, users -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们获取ViewModel实例的时候，ViewModel是通过ViewModelProvider保存在LifeCycle中，ViewModel会一直保存在LifeCycle中，直到Activity或者Fragment销毁了，触发LifeCycle被销毁，那么ViewModel也会被销毁的。下面是ViewModel的生命周期图。</p>
<p><img src="https://raw.githubusercontent.com/LiushuiXiaoxia/AndroidArchitectureComponents/master/doc/viewmodel-lifecycle.png" alt=""></p>
<h3 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h3><p>（未完待续）</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/29/fixing_npm_permissions/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://dxyoo7.github.io">Martin D</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>